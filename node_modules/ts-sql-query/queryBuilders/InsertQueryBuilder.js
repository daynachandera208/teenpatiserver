"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InsertQueryBuilder = void 0;
const Column_1 = require("../utils/Column");
const chained_error_1 = require("chained-error");
const attachSource_1 = require("../utils/attachSource");
const symbols_1 = require("../utils/symbols");
const ITableOrView_1 = require("../utils/ITableOrView");
// one implement ommited intentionally to don't confuse TypeScript
class InsertQueryBuilder {
    constructor(sqlBuilder, table) {
        this.__sets = {};
        this.__isMultiple = false;
        this.__withs = [];
        // cache
        this.__query = '';
        this.__params = [];
        this.__sqlBuilder = sqlBuilder;
        this.__table = table;
    }
    executeInsert() {
        this.query();
        const source = new Error('Query executed at');
        try {
            const idColumn = this.__idColumn;
            const multiple = this.__multiple;
            if (multiple && multiple.length <= 0) {
                if (idColumn) {
                    return this.__sqlBuilder._queryRunner.createResolvedPromise([]);
                }
                else {
                    return this.__sqlBuilder._queryRunner.createResolvedPromise(0);
                }
            }
            else if (!idColumn) {
                return this.__sqlBuilder._queryRunner.executeInsert(this.__query, this.__params).catch((e) => {
                    throw attachSource_1.attachSource(new chained_error_1.default(e), source);
                });
            }
            else if (!multiple) {
                return this.__sqlBuilder._queryRunner.executeInsertReturningLastInsertedId(this.__query, this.__params).then((value) => {
                    if (value === undefined) {
                        value = null;
                    }
                    const idColumnPrivate = Column_1.__getColumnPrivate(idColumn);
                    const typeAdapter = idColumnPrivate.__typeAdapter;
                    let result;
                    if (typeAdapter) {
                        result = typeAdapter.transformValueFromDB(value, idColumnPrivate.__valueType, this.__sqlBuilder._defaultTypeAdapter);
                    }
                    else {
                        result = this.__sqlBuilder._defaultTypeAdapter.transformValueFromDB(value, idColumnPrivate.__valueType);
                    }
                    if (result === null || result === undefined) {
                        if (!idColumnPrivate.__isResultOptional(this.__sqlBuilder)) {
                            throw new Error('Expected a value as result of the insert returning last inserted id, but null or undefined value was found');
                        }
                    }
                    if (this.__isMultiple) {
                        return [result];
                    }
                    else {
                        return result;
                    }
                }).catch((e) => {
                    throw attachSource_1.attachSource(new chained_error_1.default(e), source);
                });
            }
            else {
                return this.__sqlBuilder._queryRunner.executeInsertReturningMultipleLastInsertedId(this.__query, this.__params).then((rows) => {
                    const idColumnPrivate = Column_1.__getColumnPrivate(idColumn);
                    const typeAdapter = idColumnPrivate.__typeAdapter;
                    const columnType = idColumnPrivate.__valueType;
                    const defaultTypeAdapter = this.__sqlBuilder._defaultTypeAdapter;
                    if (typeAdapter) {
                        return rows.map((row, index) => {
                            const result = typeAdapter.transformValueFromDB(row, columnType, defaultTypeAdapter);
                            if (result === null || result === undefined) {
                                if (!idColumnPrivate.__isResultOptional(this.__sqlBuilder)) {
                                    throw new Error('Expected a value as result of the insert returning last inserted id, but null or undefined value was found at index ' + index);
                                }
                            }
                            return result;
                        });
                    }
                    else {
                        return rows.map((row, index) => {
                            const result = defaultTypeAdapter.transformValueFromDB(row, columnType);
                            if (result === null || result === undefined) {
                                if (!idColumnPrivate.__isResultOptional(this.__sqlBuilder)) {
                                    throw new Error('Expected a value as result of the insert returning last inserted id, but null or undefined value was found at index ' + index);
                                }
                            }
                            return result;
                        });
                    }
                }).catch((e) => {
                    throw attachSource_1.attachSource(new chained_error_1.default(e), source);
                });
            }
        }
        catch (e) {
            throw new chained_error_1.default(e);
        }
    }
    query() {
        if (this.__query) {
            return this.__query;
        }
        try {
            if (this.__from) {
                this.__query = this.__sqlBuilder._buildInsertFromSelect(this, this.__params);
            }
            else if (this.__multiple) {
                this.__query = this.__sqlBuilder._buildInsertMultiple(this, this.__params);
            }
            else if (this.__sets === DEFAULT_VALUES) {
                this.__query = this.__sqlBuilder._buildInsertDefaultValues(this, this.__params);
            }
            else {
                this.__query = this.__sqlBuilder._buildInsert(this, this.__params);
            }
        }
        catch (e) {
            throw new chained_error_1.default(e);
        }
        return this.__query;
    }
    params() {
        if (!this.__query) {
            this.query();
        }
        return this.__params;
    }
    dynamicSet() {
        this.__query = '';
        return this;
    }
    set(columns) {
        this.__query = '';
        if (!columns) {
            return this;
        }
        let sets = this.__sets;
        const properties = Object.getOwnPropertyNames(columns);
        for (let i = 0, length = properties.length; i < length; i++) {
            const property = properties[i];
            const value = columns[property];
            sets[property] = value;
        }
        return this;
    }
    setIfValue(columns) {
        this.__query = '';
        if (!columns) {
            return this;
        }
        let sets = this.__sets;
        const properties = Object.getOwnPropertyNames(columns);
        for (let i = 0, length = properties.length; i < length; i++) {
            const property = properties[i];
            const value = columns[property];
            if (!this.__sqlBuilder._isValue(value)) {
                continue;
            }
            sets[property] = value;
        }
        return this;
    }
    setIfSet(columns) {
        this.__query = '';
        if (!columns) {
            return this;
        }
        let sets = this.__sets;
        const properties = Object.getOwnPropertyNames(columns);
        for (let i = 0, length = properties.length; i < length; i++) {
            const property = properties[i];
            if (!(property in sets)) {
                continue;
            }
            const value = columns[property];
            sets[property] = value;
        }
        return this;
    }
    setIfSetIfValue(columns) {
        this.__query = '';
        if (!columns) {
            return this;
        }
        let sets = this.__sets;
        const properties = Object.getOwnPropertyNames(columns);
        for (let i = 0, length = properties.length; i < length; i++) {
            const property = properties[i];
            if (!(property in sets)) {
                continue;
            }
            const value = columns[property];
            if (!this.__sqlBuilder._isValue(value)) {
                continue;
            }
            sets[property] = value;
        }
        return this;
    }
    setIfNotSet(columns) {
        this.__query = '';
        if (!columns) {
            return this;
        }
        let sets = this.__sets;
        const properties = Object.getOwnPropertyNames(columns);
        for (let i = 0, length = properties.length; i < length; i++) {
            const property = properties[i];
            if (property in sets) {
                continue;
            }
            const value = columns[property];
            sets[property] = value;
        }
        return this;
    }
    setIfNotSetIfValue(columns) {
        this.__query = '';
        if (!columns) {
            return this;
        }
        let sets = this.__sets;
        const properties = Object.getOwnPropertyNames(columns);
        for (let i = 0, length = properties.length; i < length; i++) {
            const property = properties[i];
            if (property in sets) {
                continue;
            }
            const value = columns[property];
            if (!this.__sqlBuilder._isValue(value)) {
                continue;
            }
            sets[property] = value;
        }
        return this;
    }
    ignoreIfSet(...columns) {
        this.__query = '';
        let sets = this.__sets;
        for (let i = 0, length = columns.length; i < length; i++) {
            let column = columns[i];
            delete sets[column];
        }
        return this;
    }
    values(columns) {
        if (Array.isArray(columns)) {
            this.__isMultiple = true;
            if (columns.length == 1) {
                return this.set(columns[0]);
            }
            this.__multiple = columns;
            return this;
        }
        else {
            return this.set(columns);
        }
    }
    from(select) {
        this.__from = select;
        ITableOrView_1.__addWiths(select, this.__withs);
        return this;
    }
}
exports.InsertQueryBuilder = InsertQueryBuilder;
// Defined separated to don't have problems with the variable definition of this method
InsertQueryBuilder.prototype.defaultValues = function () {
    const thiz = this;
    thiz.__query = '';
    thiz.__sets = DEFAULT_VALUES;
    return thiz;
};
InsertQueryBuilder.prototype.returningLastInsertedId = function () {
    const thiz = this;
    thiz.__query = '';
    const table = thiz.__table;
    for (var columnName in table) {
        const column = Column_1.__getColumnOfTable(table, columnName);
        if (!column) {
            continue;
        }
        const columnPrivate = Column_1.__getColumnPrivate(column);
        if (!columnPrivate.__isAutogeneratedPrimaryKey) {
            continue;
        }
        if (thiz.__idColumn) {
            throw new Error('In order to call executeInsertReturningLastInsertedId method the table must have defined only one autogenerated primary key column');
        }
        thiz.__idColumn = column;
    }
    if (!thiz.__idColumn) {
        throw new Error('In order to call executeInsertReturningLastInsertedId method the table must have defined one autogenerated primary key column');
    }
    return thiz;
};
const DEFAULT_VALUES = {};
//# sourceMappingURL=InsertQueryBuilder.js.map