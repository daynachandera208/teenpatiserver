import type { SqlBuilder, JoinData, ToSql, SelectData } from "../sqlBuilders/SqlBuilder";
import type { SelectExpression, SelectColumns, OrderByMode, SelectExpressionSubquery, ExecutableSelectExpressionWithoutWhere, DynamicWhereExecutableSelectExpression, GroupByOrderByExecutableSelectExpression, OffsetExecutableSelectExpression, ExecutableSelect, DynamicWhereExpressionWithoutSelect, SelectExpressionFromNoTable, SelectWhereJoinExpression, DynamicOnExpression, OnExpression, SelectExpressionWithoutJoin, SelectWhereExpression, OrderByExecutableSelectExpression, GroupByOrderByHavingExecutableSelectExpression, DynamicHavingExecutableSelectExpression, GroupByOrderHavingByExpressionWithoutSelect, DynamicHavingExpressionWithoutSelect, ExecutableSelectWithoutGroupBy, OffsetExecutableSelectExpressionWithoutGroupBy, OrderByExecutableSelectExpressionWithoutGroupBy } from "../expressions/select";
import type { HasAddWiths, ITableOrView, IWithView, OuterJoinSource } from "../utils/ITableOrView";
import type { BooleanValueSource, NumberValueSource, IntValueSource, ValueSource, IfValueSource, IIfValueSource, IBooleanValueSource, INumberValueSource, IIntValueSource } from "../expressions/values";
import type { int } from "ts-extended-types";
import { columnsType, database, requiredTableOrView, resultType, type } from "../utils/symbols";
export declare class SelectQueryBuilder implements ToSql, HasAddWiths, SelectData, SelectExpression<any, any, any>, SelectExpressionFromNoTable<any>, ExecutableSelectExpressionWithoutWhere<any, any, any, any, any, any>, DynamicWhereExecutableSelectExpression<any, any, any, any, any, any>, DynamicWhereExpressionWithoutSelect<any, any, any>, GroupByOrderByExecutableSelectExpression<any, any, any, any, any, any>, OffsetExecutableSelectExpression<any, any, any, any>, ExecutableSelect<any, any, any, any>, SelectWhereJoinExpression<any, any, any>, DynamicOnExpression<any, any, any>, OnExpression<any, any, any>, SelectExpressionWithoutJoin<any, any, any>, SelectExpressionSubquery<any, any>, SelectWhereExpression<any, any, any>, OrderByExecutableSelectExpression<any, any, any, any, any, any>, GroupByOrderByHavingExecutableSelectExpression<any, any, any, any, any, any>, DynamicHavingExecutableSelectExpression<any, any, any, any, any, any>, GroupByOrderHavingByExpressionWithoutSelect<any, any, any>, DynamicHavingExpressionWithoutSelect<any, any, any>, ExecutableSelectWithoutGroupBy<any, any, any, any>, OffsetExecutableSelectExpressionWithoutGroupBy<any, any, any, any>, OrderByExecutableSelectExpressionWithoutGroupBy<any, any, any, any, any, any> {
    [database]: any;
    [requiredTableOrView]: any;
    [type]: 'ExecutableSelect';
    [resultType]: any;
    [columnsType]: any;
    __sqlBuilder: SqlBuilder;
    __distinct: boolean;
    __columns: {
        [property: string]: ValueSource<any, any>;
    };
    __tables_or_views: Array<ITableOrView<any>>;
    __joins: Array<JoinData>;
    __where?: BooleanValueSource<any, any> | IfValueSource<any, any>;
    __having?: BooleanValueSource<any, any> | IfValueSource<any, any>;
    __groupBy: Array<ValueSource<any, any>>;
    __orderBy?: {
        [property: string]: OrderByMode | null | undefined;
    };
    __limit?: int | number | NumberValueSource<any, any> | IntValueSource<any, any>;
    __offset?: int | number | NumberValueSource<any, any> | IntValueSource<any, any>;
    __withs: Array<IWithView<any>>;
    __lastJoin?: JoinData;
    __inHaving: boolean;
    __oneColumn: boolean;
    __query: string;
    __params: any[];
    constructor(sqlBuilder: SqlBuilder, tables: Array<ITableOrView<any>>, distinct: boolean);
    __transformValueFromDB(valueSource: ValueSource<any, any>, value: any, column?: string, index?: number, count?: boolean): unknown;
    __transformRow(row: any, index?: number): any;
    executeSelectNoneOrOne(): Promise<any>;
    executeSelectOne(): Promise<any>;
    executeSelectMany(): Promise<any>;
    __executeSelectCount(source: Error): Promise<any>;
    executeSelectPage(extras?: any): Promise<any>;
    query(): string;
    params(): any[];
    select(columns: SelectColumns<any, any>): this;
    selectOneColumn(column: ValueSource<any, any>): this;
    from(table: ITableOrView<any>): this;
    join(table: ITableOrView<any>): this;
    innerJoin(table: ITableOrView<any>): this;
    leftJoin(source: OuterJoinSource<any, any>): this;
    leftOuterJoin(source: OuterJoinSource<any, any>): this;
    dynamicOn(): this;
    on(condition: IBooleanValueSource<any, any> | IIfValueSource<any, any>): this;
    __finishJoinHaving(): void;
    dynamicWhere(): this;
    where(condition: IBooleanValueSource<any, any> | IIfValueSource<any, any>): this;
    and(condition: IBooleanValueSource<any, any> | IIfValueSource<any, any>): this;
    or(condition: IBooleanValueSource<any, any> | IIfValueSource<any, any>): this;
    dynamicHaving(): this;
    having(condition: IBooleanValueSource<any, any> | IIfValueSource<any, any>): this;
    groupBy(...columns: Array<string | number | symbol | ValueSource<any, any>>): this;
    orderBy(column: any, mode?: OrderByMode): this;
    orderByFromString(orderBy: string): this;
    limit(limit: int | number | INumberValueSource<any, any> | IIntValueSource<any, any>): this;
    offset(offset: int | number | INumberValueSource<any, any> | IIntValueSource<any, any>): this;
    __toSql(sqlBuilder: SqlBuilder, params: any[]): string;
    __toSqlForCondition(sqlBuilder: SqlBuilder, params: any[]): string;
    __addWiths(withs: Array<IWithView<any>>): void;
    forUseInQueryAs: never;
}
