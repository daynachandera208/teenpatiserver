"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LoopBackSqlServerQueryRunner = exports.LoopBackPostgreSqlQueryRunner = exports.LoopBackOracleQueryRunner = exports.LoopBackMySqlQueryRunner = exports.LoopBackAbstractQueryRunner = exports.createLoopBackQueryRunner = void 0;
function createLoopBackQueryRunner(datasource, transaction) {
    const connector = datasource.connector;
    if (!connector) {
        throw new Error('The provided datasource have no connector loaded');
    }
    switch (connector.name) {
        case 'mysql':
            return new LoopBackMySqlQueryRunner(datasource, transaction);
        case 'oracle':
            return new LoopBackOracleQueryRunner(datasource, transaction);
        case 'postgresql':
            return new LoopBackPostgreSqlQueryRunner(datasource, transaction);
        case 'mssql':
            return new LoopBackSqlServerQueryRunner(datasource, transaction);
        case 'sqlite3':
            return new LoopBackSqliteQueryRunner(datasource, transaction);
        default:
            throw new Error('Unsupported Loopback connector of name ' + connector.name);
    }
}
exports.createLoopBackQueryRunner = createLoopBackQueryRunner;
class LoopBackAbstractQueryRunner {
    constructor(database, datasource, transaction) {
        this.database = database;
        this.datasource = datasource;
        this.transaction = transaction;
        const connector = datasource.connector;
        if (!connector) {
            throw new Error('The provided datasource have no connector loaded');
        }
        this.connectorName = connector.name;
    }
    useDatabase(database) {
        if (database !== this.database) {
            throw new Error('Unsupported database: ' + database + '. The current datasource used in LoopbackQueryRunner only supports ' + this.database + ' databases');
        }
    }
    getNativeRunner() {
        return this.datasource;
    }
    execute(fn) {
        return fn(this.datasource, this.transaction);
    }
    executeSelectOneRow(query, params = []) {
        return this.query(query, params).then((rows) => {
            if (rows.length > 1) {
                throw new Error('Too many rows, expected only zero or one row');
            }
            return rows[0];
        });
    }
    executeSelectManyRows(query, params = []) {
        return this.query(query, params);
    }
    executeSelectOneColumnOneRow(query, params = []) {
        return this.query(query, params).then((rows) => {
            if (rows.length > 1) {
                throw new Error('Too many rows, expected only zero or one row');
            }
            const row = rows[0];
            if (row) {
                const columns = Object.getOwnPropertyNames(row);
                if (columns.length > 1) {
                    throw new Error('Too many columns, expected only one column');
                }
                return row[columns[0]]; // Value in the row of the first column without care about the name
            }
            return undefined;
        });
    }
    executeSelectOneColumnManyRows(query, params = []) {
        return this.query(query, params).then((rows) => rows.map((row) => {
            const columns = Object.getOwnPropertyNames(row);
            if (columns.length > 1) {
                throw new Error('Too many columns, expected only one column');
            }
            return row[columns[0]]; // Value in the row of the first column without care about the name
        }));
    }
    executeProcedure(query, params = []) {
        return this.query(query, params).then(() => undefined);
    }
    executeFunction(query, params = []) {
        return this.query(query, params).then((rows) => {
            if (rows.length > 1) {
                throw new Error('Too many rows, expected only zero or one row');
            }
            const row = rows[0];
            if (row) {
                const columns = Object.getOwnPropertyNames(row);
                if (columns.length > 1) {
                    throw new Error('Too many columns, expected only one column');
                }
                return row[columns[0]]; // Value in the row of the first column without care about the name
            }
            return undefined;
        });
    }
    executeBeginTransaction() {
        return this.datasource.beginTransaction({}).then((transaction) => {
            this.transaction = transaction;
        });
    }
    executeCommit() {
        if (!this.transaction) {
            return Promise.reject(new Error('Not in an transaction, you cannot commit the transaction'));
        }
        return this.transaction.commit().then(() => {
            this.transaction = undefined;
        });
    }
    executeRollback() {
        if (!this.transaction) {
            return Promise.reject(new Error('Not in an transaction, you cannot rollback the transaction'));
        }
        return this.transaction.rollback().then(() => {
            this.transaction = undefined;
        });
    }
    executeDatabaseSchemaModification(query, params = []) {
        return this.query(query, params).then(() => undefined);
    }
    addOutParam(_params, _name) {
        throw new Error('Unsupported output parameters');
    }
    createResolvedPromise(result) {
        return Promise.resolve(result);
    }
    query(query, params) {
        return this.datasource.execute(query, params, { transaction: this.transaction });
    }
}
exports.LoopBackAbstractQueryRunner = LoopBackAbstractQueryRunner;
class LoopBackMySqlQueryRunner extends LoopBackAbstractQueryRunner {
    constructor(datasource, transaction) {
        super('mySql', datasource, transaction);
        if (this.connectorName !== 'mysql') {
            throw new Error('Unsupported connector type: ' + this.connectorName + '. LoopBackMySqlQueryRunner only supports mysql connectors');
        }
    }
    useDatabase(database) {
        if (database !== this.database) {
            if (this.database === 'mySql' && database === 'mariaDB') {
                //@ts-ignore
                this.database = database;
            }
            else if (this.database === 'mariaDB' && database === 'mySql') {
                //@ts-ignore
                this.database = database;
            }
            else {
                throw new Error('Unsupported database: ' + database + '. The current datasource used in LoopbackQueryRunner only supports mySql or mariaDB databases');
            }
        }
    }
    executeInsert(query, params = []) {
        return this.query(query, params).then((result) => {
            return result.affectedRows;
        });
    }
    executeInsertReturningLastInsertedId(query, params = []) {
        return this.query(query, params).then((result) => {
            return result.insertId;
        });
    }
    executeInsertReturningMultipleLastInsertedId(_query, _params = []) {
        throw new Error('Unsupported executeInsertReturningMultipleLastInsertedId for this database');
    }
    executeUpdate(query, params = []) {
        return this.query(query, params).then((result) => {
            return result.affectedRows;
        });
    }
    executeDelete(query, params = []) {
        return this.query(query, params).then((result) => {
            return result.affectedRows;
        });
    }
    addParam(params, value) {
        params.push(value);
        return '?';
    }
}
exports.LoopBackMySqlQueryRunner = LoopBackMySqlQueryRunner;
class LoopBackOracleQueryRunner extends LoopBackAbstractQueryRunner {
    constructor(datasource, transaction) {
        super('oracle', datasource, transaction);
        if (this.connectorName !== 'oracle') {
            throw new Error('Unsupported connector type: ' + this.connectorName + '. LoopBackMySqlQueryRunner only supports oracle connectors');
        }
    }
    executeInsert(query, params = []) {
        return this.query(query, params).then((result) => {
            return result.rowsAffected;
        });
    }
    executeInsertReturningLastInsertedId(query, params = []) {
        return this.query(query, params).then((result) => {
            const outBinds = result.outBinds;
            if (!outBinds) {
                throw new Error('Unable to find the last inserted id, no outBinds');
            }
            else if (Array.isArray(outBinds)) {
                if (outBinds.length === 1) {
                    return getOnlyOneValue(outBinds[0]);
                }
            }
            else {
                throw new Error('Invalid outBinds returned by the database');
            }
            throw new Error('Unable to find the last inserted id');
        });
    }
    executeInsertReturningMultipleLastInsertedId(query, params = []) {
        return this.query(query, params).then((result) => {
            const outBinds = result.outBinds;
            if (!outBinds) {
                throw new Error('Unable to find the last inserted id, no outBinds');
            }
            else if (Array.isArray(outBinds)) {
                const result = [];
                for (let i = 0, length = outBinds.length; i < length; i++) {
                    result.push(getOnlyOneValue(outBinds[i]));
                }
                return result;
            }
            else {
                throw new Error('Invalid outBinds returned by the database');
            }
        });
    }
    executeUpdate(query, params = []) {
        return this.query(query, params).then((result) => {
            return result.rowsAffected;
        });
    }
    executeDelete(query, params = []) {
        return this.query(query, params).then((result) => {
            return result.rowsAffected;
        });
    }
    addParam(params, value) {
        const index = params.length;
        params.push(value);
        return ':' + index;
    }
    addOutParam(params, name) {
        const index = params.length;
        if (name) {
            params.push({ dir: 3003 /*oracledb.BIND_OUT*/, as: name }); // See https://github.com/oracle/node-oracledb/blob/master/lib/oracledb.js
        }
        else {
            params.push({ dir: 3003 /*oracledb.BIND_OUT*/ }); // See https://github.com/oracle/node-oracledb/blob/master/lib/oracledb.js
        }
        return ':' + index;
    }
}
exports.LoopBackOracleQueryRunner = LoopBackOracleQueryRunner;
function getOnlyOneValue(values) {
    if (Array.isArray(values)) {
        if (values.length != 1) {
            throw new Error('Unable to find the output value in the output');
        }
        return values[0];
    }
    else {
        return values;
    }
}
class LoopBackPostgreSqlQueryRunner extends LoopBackAbstractQueryRunner {
    constructor(datasource, transaction) {
        super('postgreSql', datasource, transaction);
        if (this.connectorName !== 'postgresql') {
            throw new Error('Unsupported connector type: ' + this.connectorName + '. LoopBackMySqlQueryRunner only supports postgresql connectors');
        }
    }
    executeInsert(query, params = []) {
        const rowsToInsert = this.guessInsertRowCount(query);
        if (!isNaN(rowsToInsert)) {
            return this.query(query, params).then(() => {
                return rowsToInsert;
            });
        }
        else {
            query = 'with rows as (' + query + ' returning true) select count(*) from rows';
            return this.query(query, params).then((result) => {
                if (result.length > 1) {
                    throw new Error('Too many rows, expected only zero or one row');
                }
                const row = result[0];
                if (row) {
                    const columns = Object.getOwnPropertyNames(row);
                    if (columns.length > 1) {
                        throw new Error('Too many columns, expected only one column');
                    }
                    return +row[columns[0]]; // Value in the row of the first column without care about the name
                }
                throw new Error('Unable to find the the affected row count');
            });
        }
    }
    executeInsertReturningLastInsertedId(query, params = []) {
        return this.query(query, params).then((result) => {
            if (result.length > 1) {
                throw new Error('Too many rows, expected only zero or one row');
            }
            const row = result[0];
            if (row) {
                const columns = Object.getOwnPropertyNames(row);
                if (columns.length > 1) {
                    throw new Error('Too many columns, expected only one column');
                }
                return row[columns[0]]; // Value in the row of the first column without care about the name
            }
            throw new Error('Unable to find the last inserted id');
        });
    }
    executeInsertReturningMultipleLastInsertedId(query, params = []) {
        return this.query(query, params).then((result) => {
            return result.map((row) => {
                const columns = Object.getOwnPropertyNames(row);
                if (columns.length > 1) {
                    throw new Error('Too many columns, expected only one column');
                }
                return row[columns[0]]; // Value in the row of the first column without care about the name
            });
        });
    }
    executeUpdate(query, params = []) {
        return this.query(query, params).then((result) => {
            return result.affectedRows;
        });
    }
    executeDelete(query, params = []) {
        return this.query(query, params).then((result) => {
            return result.affectedRows;
        });
    }
    addParam(params, value) {
        params.push(value);
        return '$' + params.length;
    }
    guessInsertRowCount(query) {
        const insert = query.toLowerCase();
        if (/\)\s*values\s*\(/g.test(insert)) {
            const matches = /\)\s*,\s*\(/g.exec(insert);
            if (matches) {
                return matches.length + 1;
            }
            else {
                return 1;
            }
        }
        else if (/default\s*values/.test(insert)) {
            return 1;
        }
        return NaN;
    }
}
exports.LoopBackPostgreSqlQueryRunner = LoopBackPostgreSqlQueryRunner;
class LoopBackSqlServerQueryRunner extends LoopBackAbstractQueryRunner {
    constructor(datasource, transaction) {
        super('sqlServer', datasource, transaction);
        if (this.connectorName !== 'mssql') {
            throw new Error('Unsupported connector type: ' + this.connectorName + '. LoopBackMySqlQueryRunner only supports mssql connectors');
        }
    }
    executeInsert(query, params = []) {
        return this.query(query + '; select @@ROWCOUNT as count', params).then((result) => {
            if (result.length > 1) {
                throw new Error('Too many rows, expected only zero or one row');
            }
            const row = result[0];
            if (row) {
                const columns = Object.getOwnPropertyNames(row);
                if (columns.length > 1) {
                    throw new Error('Too many columns, expected only one column');
                }
                return row[columns[0]]; // Value in the row of the first column without care about the name
            }
            throw new Error('Unable to find the affected row count');
        });
    }
    executeInsertReturningLastInsertedId(query, params = []) {
        return this.query(query, params).then((result) => {
            if (result.length > 1) {
                throw new Error('Too many rows, expected only zero or one row');
            }
            const row = result[0];
            if (row) {
                const columns = Object.getOwnPropertyNames(row);
                if (columns.length > 1) {
                    throw new Error('Too many columns, expected only one column');
                }
                return row[columns[0]]; // Value in the row of the first column without care about the name
            }
            throw new Error('Unable to find the last inserted id');
        });
    }
    executeInsertReturningMultipleLastInsertedId(query, params = []) {
        return this.query(query, params).then((result) => {
            return result.map((row) => {
                const columns = Object.getOwnPropertyNames(row);
                if (columns.length > 1) {
                    throw new Error('Too many columns, expected only one column');
                }
                return row[columns[0]]; // Value in the row of the first column without care about the name
            });
        });
    }
    executeUpdate(query, params = []) {
        return this.query(query + '; select @@ROWCOUNT as count', params).then((result) => {
            if (result.length > 1) {
                throw new Error('Too many rows, expected only zero or one row');
            }
            const row = result[0];
            if (row) {
                const columns = Object.getOwnPropertyNames(row);
                if (columns.length > 1) {
                    throw new Error('Too many columns, expected only one column');
                }
                return row[columns[0]]; // Value in the row of the first column without care about the name
            }
            throw new Error('Unable to find the affected row count');
        });
    }
    executeDelete(query, params = []) {
        return this.query(query + '; select @@ROWCOUNT as count', params).then((result) => {
            if (result.length > 1) {
                throw new Error('Too many rows, expected only zero or one row');
            }
            const row = result[0];
            if (row) {
                const columns = Object.getOwnPropertyNames(row);
                if (columns.length > 1) {
                    throw new Error('Too many columns, expected only one column');
                }
                return row[columns[0]]; // Value in the row of the first column without care about the name
            }
            throw new Error('Unable to find the affected row count');
        });
    }
    addParam(params, value) {
        params.push(value);
        return '@param' + params.length;
    }
}
exports.LoopBackSqlServerQueryRunner = LoopBackSqlServerQueryRunner;
class LoopBackSqliteQueryRunner extends LoopBackAbstractQueryRunner {
    constructor(datasource, transaction) {
        super('sqlite', datasource, transaction);
        if (this.connectorName !== 'sqlite3') {
            throw new Error('Unsupported connector type: ' + this.connectorName + '. LoopBackMySqlQueryRunner only supports sqlite3 connectors');
        }
        // Fix invalid transaction type
        const connector = datasource.connector;
        if (!connector.__tssqlquery_transactiontypefixed) {
            const beginTransaction = connector.beginTransaction;
            connector.beginTransaction = function (isolationLevel, cb) {
                if (isolationLevel === 'READ COMMITTED' ||
                    isolationLevel === 'READ UNCOMMITTED' ||
                    isolationLevel === 'SERIALIZABLE' ||
                    isolationLevel === 'REPEATABLE READ') {
                    isolationLevel = '';
                }
                beginTransaction.call(this, isolationLevel, cb);
            };
            connector.__tssqlquery_transactiontypefixed = true;
        }
    }
    executeInsert(query, params = []) {
        return this.queryNoSelect(query, params).then((result) => {
            return result.count;
        });
    }
    executeInsertReturningLastInsertedId(query, params = []) {
        return this.queryNoSelect(query, params).then((result) => {
            return result.lastID;
        });
    }
    executeInsertReturningMultipleLastInsertedId(_query, _params = []) {
        throw new Error('Unsupported executeInsertReturningMultipleLastInsertedId for this database');
    }
    executeUpdate(query, params = []) {
        return this.queryNoSelect(query, params).then((result) => {
            return result.count;
        });
    }
    executeDelete(query, params = []) {
        return this.queryNoSelect(query, params).then((result) => {
            return result.count;
        });
    }
    addParam(params, value) {
        params.push(value);
        return '?';
    }
    query(query, params) {
        if (query.startsWith('with ')) {
            // Work-around to loopback limitation
            query = 'select * from (' + query + ')';
        }
        return this.datasource.execute(query, params, { transaction: this.transaction });
    }
    queryNoSelect(query, params) {
        return this.datasource.execute(query, params, { transaction: this.transaction });
    }
}
//# sourceMappingURL=LoopBackQueryRunner.js.map