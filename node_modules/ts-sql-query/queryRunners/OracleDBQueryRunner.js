"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.OracleDBQueryRunner = void 0;
const oracledb_1 = require("oracledb");
class OracleDBQueryRunner {
    constructor(connection) {
        this.connection = connection;
        this.database = 'oracle';
    }
    useDatabase(database) {
        if (database !== 'oracle') {
            throw new Error('Unsupported database: ' + database + '. OracleDBQueryRunner only supports oracle databases');
        }
    }
    getNativeRunner() {
        return this.connection;
    }
    execute(fn) {
        return fn(this.connection);
    }
    executeSelectOneRow(query, params = []) {
        return this.connection.execute(query, params, { outFormat: oracledb_1.OUT_FORMAT_OBJECT }).then((result) => {
            if (!result.rows) {
                return undefined;
            }
            else if (result.rows.length > 1) {
                throw new Error('Too many rows, expected only zero or one row');
            }
            return result.rows[0];
        });
    }
    executeSelectManyRows(query, params = []) {
        return this.connection.execute(query, params, { outFormat: oracledb_1.OUT_FORMAT_OBJECT }).then((result) => result.rows || []);
    }
    executeSelectOneColumnOneRow(query, params = []) {
        return this.connection.execute(query, params, { outFormat: oracledb_1.OUT_FORMAT_ARRAY }).then((result) => {
            if (!result.rows) {
                return undefined;
            }
            else if (result.rows.length > 1) {
                throw new Error('Too many rows, expected only zero or one row');
            }
            const row = result.rows[0];
            if (row) {
                if (row.length > 1) {
                    throw new Error('Too many columns, expected only one column');
                }
                return row[0];
            }
            else {
                return undefined;
            }
        });
    }
    executeSelectOneColumnManyRows(query, params = []) {
        return this.connection.execute(query, params, { outFormat: oracledb_1.OUT_FORMAT_ARRAY }).then((result) => (result.rows || []).map((row) => {
            if (row.length > 1) {
                throw new Error('Too many columns, expected only one column');
            }
            return row[0];
        }));
    }
    executeInsert(query, params = []) {
        return this.connection.execute(query, params).then((result) => result.rowsAffected || 0);
    }
    executeInsertReturningLastInsertedId(query, params = []) {
        return this.connection.execute(query, params).then((result) => {
            const outBinds = result.outBinds;
            if (!outBinds) {
                throw new Error('Unable to find the last inserted id, no outBinds');
            }
            else if (Array.isArray(outBinds)) {
                if (outBinds.length === 1) {
                    return getOnlyOneValue(outBinds[0]);
                }
            }
            else {
                throw new Error('Invalid outBinds returned by the database');
            }
            throw new Error('Unable to find the last inserted id');
        });
    }
    executeInsertReturningMultipleLastInsertedId(query, params = []) {
        return this.connection.execute(query, params).then((result) => {
            const outBinds = result.outBinds;
            if (!outBinds) {
                throw new Error('Unable to find the last inserted id, no outBinds');
            }
            else if (Array.isArray(outBinds)) {
                const result = [];
                for (let i = 0, length = outBinds.length; i < length; i++) {
                    result.push(getOnlyOneValue(outBinds[i]));
                }
                return result;
            }
            else {
                throw new Error('Invalid outBinds returned by the database');
            }
        });
    }
    executeUpdate(query, params = []) {
        return this.connection.execute(query, params).then((result) => result.rowsAffected || 0);
    }
    executeDelete(query, params = []) {
        return this.connection.execute(query, params).then((result) => result.rowsAffected || 0);
    }
    executeProcedure(query, params = []) {
        return this.connection.execute(query, params).then(() => undefined);
    }
    executeFunction(query, params = []) {
        return this.connection.execute(query, params, { outFormat: oracledb_1.OUT_FORMAT_ARRAY }).then((result) => {
            if (!result.rows) {
                throw new Error('No row found');
            }
            else if (result.rows.length !== 1) {
                throw new Error('Invalid number of rows, expected only one row');
            }
            const row = result.rows[0];
            if (row) {
                if (row.length !== 1) {
                    throw new Error('Invalid number of columns, expected only one column');
                }
                return row[0];
            }
            else {
                throw new Error('No row found');
            }
        });
    }
    executeBeginTransaction() {
        // Oracle automatically begins the transaction
        return Promise.resolve();
    }
    executeCommit() {
        return this.connection.commit();
    }
    executeRollback() {
        return this.connection.rollback();
    }
    executeDatabaseSchemaModification(query, params = []) {
        return this.connection.execute(query, params).then(() => undefined);
    }
    addParam(params, value) {
        const index = params.length;
        params.push(value);
        return ':' + index;
    }
    addOutParam(params, name) {
        const index = params.length;
        if (name) {
            params.push({ dir: oracledb_1.BIND_OUT, as: name });
        }
        else {
            params.push({ dir: oracledb_1.BIND_OUT });
        }
        return ':' + index;
    }
    createResolvedPromise(result) {
        return Promise.resolve(result);
    }
}
exports.OracleDBQueryRunner = OracleDBQueryRunner;
function getOnlyOneValue(values) {
    if (Array.isArray(values)) {
        if (values.length != 1) {
            throw new Error('Unable to find the output value in the output');
        }
        return values[0];
    }
    else {
        return values;
    }
}
//# sourceMappingURL=OracleDBQueryRunner.js.map