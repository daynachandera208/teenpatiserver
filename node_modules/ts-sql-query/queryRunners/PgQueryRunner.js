"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PgQueryRunner = void 0;
class PgQueryRunner {
    constructor(connection) {
        this.connection = connection;
        this.database = 'postgreSql';
    }
    useDatabase(database) {
        if (database !== 'postgreSql') {
            throw new Error('Unsupported database: ' + database + '. PgQueryRunner only supports postgreSql databases');
        }
    }
    getNativeRunner() {
        return this.connection;
    }
    execute(fn) {
        return fn(this.connection);
    }
    executeSelectOneRow(query, params = []) {
        return this.connection.query(query, params).then((result) => {
            if (result.rows.length > 1) {
                throw new Error('Too many rows, expected only zero or one row');
            }
            return result.rows[0];
        });
    }
    executeSelectManyRows(query, params = []) {
        return this.connection.query(query, params).then((result) => result.rows);
    }
    executeSelectOneColumnOneRow(query, params = []) {
        return this.connection.query({ text: query, values: params, rowMode: 'array' }).then((result) => {
            if (result.rows.length > 1) {
                throw new Error('Too many rows, expected only zero or one row');
            }
            const row = result.rows[0];
            if (row) {
                if (row.length > 1) {
                    throw new Error('Too many columns, expected only one column');
                }
                return row[0];
            }
            else {
                return undefined;
            }
        });
    }
    executeSelectOneColumnManyRows(query, params = []) {
        return this.connection.query({ text: query, values: params, rowMode: 'array' }).then((result) => result.rows.map((row) => {
            if (row.length > 1) {
                throw new Error('Too many columns, expected only one column');
            }
            return row[0];
        }));
    }
    executeInsert(query, params = []) {
        return this.connection.query(query, params).then((result) => result.rowCount);
    }
    executeInsertReturningLastInsertedId(query, params = []) {
        return this.connection.query({ text: query, values: params, rowMode: 'array' }).then((result) => {
            if (result.rows.length > 1) {
                throw new Error('Too many rows, expected only zero or one row');
            }
            const row = result.rows[0];
            if (row) {
                if (row.length > 1) {
                    throw new Error('Too many columns, expected only one column');
                }
                return row[0];
            }
            else {
                throw new Error('Unable to find the last inserted id');
            }
        });
    }
    executeInsertReturningMultipleLastInsertedId(query, params = []) {
        return this.connection.query({ text: query, values: params, rowMode: 'array' }).then((result) => {
            return result.rows.map((row) => {
                if (row.length > 1) {
                    throw new Error('Too many columns, expected only one column');
                }
                return row[0];
            });
        });
    }
    executeUpdate(query, params = []) {
        return this.connection.query(query, params).then((result) => result.rowCount);
    }
    executeDelete(query, params = []) {
        return this.connection.query(query, params).then((result) => result.rowCount);
    }
    executeProcedure(query, params = []) {
        return this.connection.query(query, params).then(() => undefined);
    }
    executeFunction(query, params = []) {
        return this.connection.query({ text: query, values: params, rowMode: 'array' }).then((result) => {
            if (result.rows.length > 1) {
                throw new Error('Too many rows, expected only zero or one row');
            }
            const row = result.rows[0];
            if (row) {
                if (row.length > 1) {
                    throw new Error('Too many columns, expected only one column');
                }
                return row[0];
            }
            else {
                return undefined;
            }
        });
    }
    executeBeginTransaction() {
        return this.connection.query('begin transaction').then(() => undefined);
    }
    executeCommit() {
        return this.connection.query('commit').then(() => undefined);
    }
    executeRollback() {
        return this.connection.query('rollback').then(() => undefined);
    }
    executeDatabaseSchemaModification(query, params = []) {
        return this.connection.query(query, params).then(() => undefined);
    }
    addParam(params, value) {
        params.push(value);
        return '$' + params.length;
    }
    addOutParam(_params, _name) {
        throw new Error('Unsupported output parameters');
    }
    createResolvedPromise(result) {
        return Promise.resolve(result);
    }
}
exports.PgQueryRunner = PgQueryRunner;
//# sourceMappingURL=PgQueryRunner.js.map