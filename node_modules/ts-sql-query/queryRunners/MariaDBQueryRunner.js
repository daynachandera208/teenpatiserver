"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MariaDBQueryRunner = void 0;
class MariaDBQueryRunner {
    constructor(connection, database = 'mariaDB') {
        this.connection = connection;
        this.database = database;
    }
    useDatabase(database) {
        if (database !== 'mariaDB' && database !== 'mySql') {
            throw new Error('Unsupported database: ' + database + '. MariaDBQueryRunner only supports mariaDB or mySql databases');
        }
        else {
            // @ts-ignore
            this.database = database;
        }
    }
    getNativeRunner() {
        return this.connection;
    }
    execute(fn) {
        return fn(this.connection);
    }
    executeSelectOneRow(query, params = []) {
        return this.connection.query({ sql: query, bigNumberStrings: true }, params).then((result) => {
            if (result.length > 1) {
                throw new Error('Too many rows, expected only zero or one row');
            }
            return result[0];
        });
    }
    executeSelectManyRows(query, params = []) {
        return this.connection.query({ sql: query, bigNumberStrings: true }, params);
    }
    executeSelectOneColumnOneRow(query, params = []) {
        return this.connection.query({ sql: query, rowsAsArray: true, bigNumberStrings: true }, params).then((result) => {
            if (result.length > 1) {
                throw new Error('Too many rows, expected only zero or one row');
            }
            const row = result[0];
            if (row) {
                if (row.length > 1) {
                    throw new Error('Too many columns, expected only one column');
                }
                return row[0];
            }
            else {
                return undefined;
            }
        });
    }
    executeSelectOneColumnManyRows(query, params = []) {
        return this.connection.query({ sql: query, rowsAsArray: true, bigNumberStrings: true }, params).then((result) => result.map((row) => {
            if (row.length > 1) {
                throw new Error('Too many columns, expected only one column');
            }
            return row[0];
        }));
    }
    executeInsert(query, params = []) {
        return this.connection.query({ sql: query, bigNumberStrings: true }, params).then((result) => result.affectedRows);
    }
    executeInsertReturningLastInsertedId(query, params = []) {
        return this.connection.query({ sql: query, bigNumberStrings: true }, params).then((result) => result.insertId);
    }
    executeInsertReturningMultipleLastInsertedId(_query, _params = []) {
        throw new Error('Unsupported executeInsertReturningLastInsertedId for this database');
    }
    executeUpdate(query, params = []) {
        return this.connection.query({ sql: query, bigNumberStrings: true }, params).then((result) => result.affectedRows);
    }
    executeDelete(query, params = []) {
        return this.connection.query({ sql: query, bigNumberStrings: true }, params).then((result) => result.affectedRows);
    }
    executeProcedure(query, params = []) {
        return this.connection.query({ sql: query, bigNumberStrings: true }, params).then(() => undefined);
    }
    executeFunction(query, params = []) {
        return this.connection.query({ sql: query, rowsAsArray: true, bigNumberStrings: true }, params).then((result) => {
            if (result.length > 1) {
                throw new Error('Too many rows, expected only zero or one row');
            }
            const row = result[0];
            if (row) {
                if (row.length > 1) {
                    throw new Error('Too many columns, expected only one column');
                }
                return row[0];
            }
            else {
                return undefined;
            }
        });
    }
    executeBeginTransaction() {
        return this.connection.beginTransaction();
    }
    executeCommit() {
        return this.connection.commit();
    }
    executeRollback() {
        return this.connection.rollback();
    }
    executeDatabaseSchemaModification(query, params = []) {
        return this.connection.query({ sql: query, bigNumberStrings: true }, params).then(() => undefined);
    }
    addParam(params, value) {
        params.push(value);
        return '?';
    }
    addOutParam(_params, _name) {
        throw new Error('Unsupported output parameters');
    }
    createResolvedPromise(result) {
        return Promise.resolve(result);
    }
}
exports.MariaDBQueryRunner = MariaDBQueryRunner;
//# sourceMappingURL=MariaDBQueryRunner.js.map