"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TediousQueryRunner = void 0;
const tedious_1 = require("tedious");
class TediousQueryRunner {
    constructor(connection) {
        this.predefinedTypes = {
            boolean: tedious_1.TYPES.Bit,
            stringInt: tedious_1.TYPES.BigInt,
            int: tedious_1.TYPES.Int,
            bigint: tedious_1.TYPES.BigInt,
            stringDouble: tedious_1.TYPES.Float,
            double: tedious_1.TYPES.Real,
            string: tedious_1.TYPES.NVarChar,
            localDate: tedious_1.TYPES.Date,
            localTime: tedious_1.TYPES.Time,
            localDateTime: tedious_1.TYPES.DateTime2
        };
        this.connection = connection;
        this.database = 'sqlServer';
    }
    useDatabase(database) {
        if (database !== 'sqlServer') {
            throw new Error('Unsupported database: ' + database + '. TediousQueryRunner only supports sqlServer databases');
        }
    }
    getNativeRunner() {
        return this.connection;
    }
    execute(fn) {
        return fn(this.connection);
    }
    executeSelectOneRow(query, params = []) {
        return new Promise((resolve, reject) => {
            let result = null;
            const req = new tedious_1.Request(query, (error) => {
                if (error) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            });
            for (var i = 0, length = params.length; i < length; i++) {
                req.addParameter('' + i, this.getType(params, i), params[i]);
            }
            req.on('row', function (columns) {
                if (result !== null) {
                    reject(Error('Too many rows, expected only zero or one row'));
                }
                result = {};
                for (var i = 0, length = columns.length; i < length; i++) {
                    const column = columns[i];
                    result[column.metadata.colName] = column.value;
                }
            });
            this.connection.execSql(req);
        });
    }
    executeSelectManyRows(query, params = []) {
        return new Promise((resolve, reject) => {
            let result = [];
            const req = new tedious_1.Request(query, (error) => {
                if (error) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            });
            for (var i = 0, length = params.length; i < length; i++) {
                req.addParameter('' + i, this.getType(params, i), params[i]);
            }
            req.on('row', function (columns) {
                const obj = {};
                for (var i = 0, length = columns.length; i < length; i++) {
                    const column = columns[i];
                    obj[column.metadata.colName] = column.value;
                }
                result.push(obj);
            });
            this.connection.execSql(req);
        });
    }
    executeSelectOneColumnOneRow(query, params = []) {
        return new Promise((resolve, reject) => {
            let result = undefined;
            const req = new tedious_1.Request(query, (error) => {
                if (error) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            });
            for (var i = 0, length = params.length; i < length; i++) {
                req.addParameter('' + i, this.getType(params, i), params[i]);
            }
            let rowFound = false;
            req.on('row', function (columns) {
                if (rowFound) {
                    reject(Error('Too many rows, expected only zero or one row'));
                }
                rowFound = true;
                if (columns.length > 1) {
                    reject(new Error('Too many columns, expected only one column'));
                }
                const column = columns[0];
                if (column) {
                    result = column.value;
                }
            });
            this.connection.execSql(req);
        });
    }
    executeSelectOneColumnManyRows(query, params = []) {
        return new Promise((resolve, reject) => {
            let result = [];
            const req = new tedious_1.Request(query, (error) => {
                if (error) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            });
            for (var i = 0, length = params.length; i < length; i++) {
                req.addParameter('' + i, this.getType(params, i), params[i]);
            }
            req.on('row', function (columns) {
                const column = columns[0];
                if (columns.length > 1) {
                    reject(new Error('Too many columns, expected only one column'));
                }
                if (column) {
                    result.push(column.value);
                }
                else {
                    result.push(undefined);
                }
            });
            this.connection.execSql(req);
        });
    }
    executeInsert(query, params = []) {
        return new Promise((resolve, reject) => {
            const req = new tedious_1.Request(query, (error, rowCount) => {
                if (error) {
                    reject(error);
                }
                else {
                    resolve(rowCount);
                }
            });
            for (var i = 0, length = params.length; i < length; i++) {
                req.addParameter('' + i, this.getType(params, i), params[i]);
            }
            this.connection.execSql(req);
        });
    }
    executeInsertReturningLastInsertedId(query, params = []) {
        return new Promise((resolve, reject) => {
            let result = undefined;
            const req = new tedious_1.Request(query, (error) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (result === undefined) {
                        reject(new Error('Unable to find the last inserted id'));
                    }
                    else {
                        resolve(result);
                    }
                }
            });
            for (var i = 0, length = params.length; i < length; i++) {
                req.addParameter('' + i, this.getType(params, i), params[i]);
            }
            let rowFound = false;
            req.on('row', function (columns) {
                if (rowFound) {
                    reject(Error('Too many rows, expected only zero or one row'));
                }
                rowFound = true;
                if (columns.length > 1) {
                    reject(new Error('Too many columns, expected only one column'));
                }
                const column = columns[0];
                if (column) {
                    result = column.value;
                }
            });
            this.connection.execSql(req);
        });
    }
    executeInsertReturningMultipleLastInsertedId(query, params = []) {
        return new Promise((resolve, reject) => {
            let result = [];
            const req = new tedious_1.Request(query, (error) => {
                if (error) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            });
            for (var i = 0, length = params.length; i < length; i++) {
                req.addParameter('' + i, this.getType(params, i), params[i]);
            }
            req.on('row', function (columns) {
                if (columns.length > 1) {
                    reject(new Error('Too many columns, expected only one column'));
                }
                const column = columns[0];
                if (column) {
                    result.push(column.value);
                }
            });
            this.connection.execSql(req);
        });
    }
    executeUpdate(query, params = []) {
        return new Promise((resolve, reject) => {
            const req = new tedious_1.Request(query, (error, rowCount) => {
                if (error) {
                    reject(error);
                }
                else {
                    resolve(rowCount);
                }
            });
            for (var i = 0, length = params.length; i < length; i++) {
                req.addParameter('' + i, this.getType(params, i), params[i]);
            }
            this.connection.execSql(req);
        });
    }
    executeDelete(query, params = []) {
        return new Promise((resolve, reject) => {
            const req = new tedious_1.Request(query, (error, rowCount) => {
                if (error) {
                    reject(error);
                }
                else {
                    resolve(rowCount);
                }
            });
            for (var i = 0, length = params.length; i < length; i++) {
                req.addParameter('' + i, this.getType(params, i), params[i]);
            }
            this.connection.execSql(req);
        });
    }
    executeProcedure(query, params = []) {
        return new Promise((resolve, reject) => {
            const req = new tedious_1.Request(query, (error) => {
                if (error) {
                    reject(error);
                }
                else {
                    resolve(undefined);
                }
            });
            for (var i = 0, length = params.length; i < length; i++) {
                req.addParameter('' + i, this.getType(params, i), params[i]);
            }
            this.connection.execSql(req);
        });
    }
    executeFunction(query, params = []) {
        return new Promise((resolve, reject) => {
            let result = undefined;
            const req = new tedious_1.Request(query, (error) => {
                if (error) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            });
            for (var i = 0, length = params.length; i < length; i++) {
                req.addParameter('' + i, this.getType(params, i), params[i]);
            }
            let rowFound = false;
            req.on('row', function (columns) {
                if (rowFound) {
                    reject(Error('Too many rows, expected only zero or one row'));
                }
                rowFound = true;
                if (columns.length > 1) {
                    reject(new Error('Too many columns, expected only one column'));
                }
                const column = columns[0];
                if (column) {
                    result = column.value;
                }
            });
            this.connection.execSql(req);
        });
    }
    executeBeginTransaction() {
        return new Promise((resolve, reject) => {
            this.connection.beginTransaction((error) => {
                if (error) {
                    reject(error);
                }
                else {
                    resolve();
                }
            });
        });
    }
    executeCommit() {
        return new Promise((resolve, reject) => {
            this.connection.commitTransaction((error) => {
                if (error) {
                    reject(error);
                }
                else {
                    resolve();
                }
            });
        });
    }
    executeRollback() {
        return new Promise((resolve, reject) => {
            this.connection.rollbackTransaction((error) => {
                if (error) {
                    reject(error);
                }
                else {
                    resolve();
                }
            });
        });
    }
    executeDatabaseSchemaModification(query, params = []) {
        return new Promise((resolve, reject) => {
            const req = new tedious_1.Request(query, (error) => {
                if (error) {
                    reject(error);
                }
                else {
                    resolve(undefined);
                }
            });
            for (var i = 0, length = params.length; i < length; i++) {
                req.addParameter('' + i, this.getType(params, i), params[i]);
            }
            this.connection.execSql(req);
        });
    }
    addParam(params, value) {
        const index = params.length;
        params.push(value);
        return '@' + index;
    }
    addOutParam(_params, _name) {
        throw new Error('Unsupported output parameters');
    }
    createResolvedPromise(result) {
        return Promise.resolve(result);
    }
    getType(params, index) {
        const definedType = params['@' + index];
        if (definedType) {
            const type = this.predefinedTypes[definedType];
            if (type) {
                return type;
            }
        }
        return this.inferType(params[index]);
    }
    inferType(value) {
        // Inspired by: https://github.com/Hypermediaisobar-admin/node-any-db-mssql/blob/master/index.js
        if (value === null || value === undefined) {
            return tedious_1.TYPES.Null;
        }
        else if (typeof value === 'number') {
            if (Number.isSafeInteger(value)) {
                return tedious_1.TYPES.Int;
            }
            else {
                return tedious_1.TYPES.Real;
            }
        }
        else if (typeof value === 'bigint') {
            return tedious_1.TYPES.BigInt;
        }
        else if (typeof value === 'boolean') {
            return tedious_1.TYPES.Bit;
        }
        else if (value instanceof Array) {
            return (value.length > 0 ? this.inferType(value[0]) : tedious_1.TYPES.Null);
        }
        else if (value instanceof Date) {
            switch (value.___type___) {
                case 'LocalDateTime':
                    return tedious_1.TYPES.DateTime2;
                case 'LocalDate':
                    return tedious_1.TYPES.Date;
                case 'LocalTime':
                    return tedious_1.TYPES.Time;
                default:
                    return tedious_1.TYPES.DateTime2; // Maybe: TYPES.DateTimeOffset
            }
        }
        else if (typeof value === 'string') {
            if (/^-?\d+$/.test(value)) {
                if (value.length > 9) {
                    return tedious_1.TYPES.BigInt;
                }
                else {
                    return tedious_1.TYPES.Int;
                }
            }
            else if (/^-?\d+\.\d+$/.test(value)) {
                return tedious_1.TYPES.Real;
            }
            else if (/^\d{4}-\d{2}-\d{2}$/.test(value)) {
                return tedious_1.TYPES.Date;
            }
            else if (/^\d{2}\:\d{2}(?:\:\d{2})?(?:\+\d{4})?$/.test(value)) {
                return tedious_1.TYPES.Time;
            }
            else if (/^\d{4}-\d{2}-\d{2}\s+\d{2}\:\d{2}(?:\:\d{2}(?:\.\d+)?)?$/.test(value)) {
                return tedious_1.TYPES.DateTime2;
            }
            else if (/^\d{4}-\d{2}-\d{2}T\d{2}\:\d{2}\:\d{2}(?:\.\d+)?$/.test(value)) {
                return tedious_1.TYPES.DateTime2;
            }
            else if (/^\d{4}-\d{2}-\d{2}\s+\d{2}\:\d{2}(?:\:\d{2}(?:\.\d+)?)?(?:[\+\-]\d{2}\:\d{2}|Z)?$/.test(value)) {
                return tedious_1.TYPES.DateTimeOffset;
            }
            else if (/^\d{4}-\d{2}-\d{2}T\d{2}\:\d{2}\:\d{2}(?:\.\d+)?(?:[\+\-]\d{2}\:\d{2}|Z)?$/.test(value)) {
                return tedious_1.TYPES.DateTimeOffset;
            }
            else {
                return tedious_1.TYPES.NVarChar;
            }
        }
        return tedious_1.TYPES.VarBinary;
    }
}
exports.TediousQueryRunner = TediousQueryRunner;
//# sourceMappingURL=TediousQueryRunner.js.map