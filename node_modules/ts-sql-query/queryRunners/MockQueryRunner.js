"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MockQueryRunner = void 0;
class MockQueryRunner {
    constructor(queryExecutor, databaseOrConfig = 'noopDB') {
        this.count = 0;
        this.queryExecutor = queryExecutor;
        if (typeof databaseOrConfig === 'string') {
            databaseOrConfig = { database: databaseOrConfig };
        }
        this.database = databaseOrConfig.database || 'noopDB';
        this.promise = databaseOrConfig.promise || Promise;
    }
    useDatabase(database) {
        // @ts-ignore
        this.database = database;
    }
    getNativeRunner() {
        return null;
    }
    execute(fn) {
        return fn(null);
    }
    executeSelectOneRow(query, params = []) {
        try {
            return this.promise.resolve(this.queryExecutor('selectOneRow', query, params, this.count++));
        }
        catch (e) {
            return this.promise.reject(e);
        }
    }
    executeSelectManyRows(query, params = []) {
        try {
            return this.promise.resolve(this.queryExecutor('selectManyRows', query, params, this.count++) || []);
        }
        catch (e) {
            return this.promise.reject(e);
        }
    }
    executeSelectOneColumnOneRow(query, params = []) {
        try {
            return this.promise.resolve(this.queryExecutor('selectOneColumnOneRow', query, params, this.count++));
        }
        catch (e) {
            return this.promise.reject(e);
        }
    }
    executeSelectOneColumnManyRows(query, params = []) {
        try {
            return this.promise.resolve(this.queryExecutor('selectOneColumnManyRows', query, params, this.count++) || []);
        }
        catch (e) {
            return this.promise.reject(e);
        }
    }
    executeInsert(query, params = []) {
        try {
            return this.promise.resolve(this.queryExecutor('insert', query, params, this.count++));
        }
        catch (e) {
            return this.promise.reject(e);
        }
    }
    executeInsertReturningLastInsertedId(query, params = []) {
        try {
            return this.promise.resolve(this.queryExecutor('insertReturningLastInsertedId', query, params, this.count++));
        }
        catch (e) {
            return this.promise.reject(e);
        }
    }
    executeInsertReturningMultipleLastInsertedId(query, params = []) {
        try {
            return this.promise.resolve(this.queryExecutor('insertReturningMultipleLastInsertedId', query, params, this.count++));
        }
        catch (e) {
            return this.promise.reject(e);
        }
    }
    executeUpdate(query, params = []) {
        try {
            return this.promise.resolve(this.queryExecutor('update', query, params, this.count++));
        }
        catch (e) {
            return this.promise.reject(e);
        }
    }
    executeDelete(query, params = []) {
        try {
            return this.promise.resolve(this.queryExecutor('delete', query, params, this.count++));
        }
        catch (e) {
            return this.promise.reject(e);
        }
    }
    executeProcedure(query, params = []) {
        try {
            return this.promise.resolve(this.queryExecutor('executeProcedure', query, params, this.count++));
        }
        catch (e) {
            return this.promise.reject(e);
        }
    }
    executeFunction(query, params = []) {
        try {
            return this.promise.resolve(this.queryExecutor('executeFunction', query, params, this.count++));
        }
        catch (e) {
            return this.promise.reject(e);
        }
    }
    executeBeginTransaction() {
        try {
            return this.promise.resolve(this.queryExecutor('beginTransaction', 'begin transaction', [], this.count++));
        }
        catch (e) {
            return this.promise.reject(e);
        }
    }
    executeCommit() {
        try {
            return this.promise.resolve(this.queryExecutor('commit', 'commit', [], this.count++));
        }
        catch (e) {
            return this.promise.reject(e);
        }
    }
    executeRollback() {
        try {
            return this.promise.resolve(this.queryExecutor('rollback', 'rollback', [], this.count++));
        }
        catch (e) {
            return this.promise.reject(e);
        }
    }
    executeDatabaseSchemaModification(query, params = []) {
        try {
            return this.promise.resolve(this.queryExecutor('executeDatabaseSchemaModification', query, params, this.count++));
        }
        catch (e) {
            return this.promise.reject(e);
        }
    }
    addParam(params, value) {
        const index = params.length;
        let result;
        switch (this.database) {
            case 'mariaDB':
                result = '?';
                break;
            case 'mySql':
                result = '?';
                break;
            case 'noopDB':
                result = '$' + index;
                break;
            case 'oracle':
                result = ':' + index;
                break;
            case 'postgreSql':
                result = '$' + (index + 1);
                break;
            case 'sqlite':
                result = '?';
                break;
            case 'sqlServer':
                result = '@' + index;
                break;
            default:
                throw new Error('Unknown database ' + this.database);
        }
        params.push(value);
        return result;
    }
    addOutParam(params, name) {
        const index = params.length;
        params.push({ out_param_with_name: name });
        return ':' + index;
    }
    createResolvedPromise(result) {
        return this.promise.resolve(result);
    }
}
exports.MockQueryRunner = MockQueryRunner;
//# sourceMappingURL=MockQueryRunner.js.map