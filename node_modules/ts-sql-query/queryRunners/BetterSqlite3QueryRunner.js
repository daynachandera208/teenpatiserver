"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BetterSqlite3QueryRunner = void 0;
const better_sqlite3_1 = require("better-sqlite3");
class BetterSqlite3QueryRunner {
    constructor(connection, config) {
        this.connection = connection;
        this.database = 'sqlite';
        this.promise = config?.promise || Promise;
    }
    useDatabase(database) {
        if (database !== 'sqlite') {
            throw new Error('Unsupported database: ' + database + '. BetterSqlite3QueryRunner only supports sqlite databases');
        }
    }
    getNativeRunner() {
        return this.connection;
    }
    execute(fn) {
        return fn(this.connection);
    }
    executeSelectOneRow(query, params = []) {
        try {
            const rows = this.connection.prepare(query).safeIntegers(true).all(params);
            if (rows.length > 1) {
                this.promise.reject(new Error('Too many rows, expected only zero or one row'));
            }
            const row = rows[0];
            for (var prop in row) {
                row[prop] = toStringInt(row[prop]);
            }
            return this.promise.resolve(row);
        }
        catch (e) {
            return this.promise.reject(e);
        }
    }
    executeSelectManyRows(query, params = []) {
        try {
            const rows = this.connection.prepare(query).safeIntegers(true).all(params);
            for (var i = 0, length = rows.length; i < length; i++) {
                const row = rows[i];
                for (var prop in row) {
                    row[prop] = toStringInt(row[prop]);
                }
            }
            return this.promise.resolve(rows);
        }
        catch (e) {
            return this.promise.reject(e);
        }
    }
    executeSelectOneColumnOneRow(query, params = []) {
        try {
            const rows = this.connection.prepare(query).safeIntegers(true).all(params);
            if (rows.length > 1) {
                return this.promise.reject(new Error('Too many rows, expected only zero or one row'));
            }
            const row = rows[0];
            if (row) {
                const columns = Object.getOwnPropertyNames(row);
                if (columns.length > 1) {
                    return this.promise.reject(new Error('Too many columns, expected only one column'));
                }
                return this.promise.resolve(toStringInt(row[columns[0]])); // Value in the row of the first column without care about the name
            }
            return this.promise.resolve(undefined);
        }
        catch (e) {
            return this.promise.reject(e);
        }
    }
    executeSelectOneColumnManyRows(query, params = []) {
        try {
            const rows = this.connection.prepare(query).safeIntegers(true).all(params);
            const result = [];
            for (let i = 0, length = rows.length; i < length; i++) {
                const row = rows[i];
                const columns = Object.getOwnPropertyNames(row);
                if (columns.length > 1) {
                    return this.promise.reject(new Error('Too many columns, expected only one column'));
                }
                result.push(toStringInt(row[columns[0]])); // Value in the row of the first column without care about the name
            }
            return this.promise.resolve(result);
        }
        catch (e) {
            return this.promise.reject(e);
        }
    }
    executeInsert(query, params = []) {
        try {
            return this.promise.resolve(this.connection.prepare(query).run(params).changes);
        }
        catch (e) {
            return this.promise.reject(e);
        }
    }
    executeInsertReturningLastInsertedId(query, params = []) {
        try {
            return this.promise.resolve(toStringInt(this.connection.prepare(query).safeIntegers(true).run(params).lastInsertRowid));
        }
        catch (e) {
            return this.promise.reject(e);
        }
    }
    executeInsertReturningMultipleLastInsertedId(_query, _params = []) {
        throw new Error('Unsupported executeInsertReturningLastInsertedId for this database');
    }
    executeUpdate(query, params = []) {
        try {
            return this.promise.resolve(this.connection.prepare(query).run(params).changes);
        }
        catch (e) {
            return this.promise.reject(e);
        }
    }
    executeDelete(query, params = []) {
        try {
            return this.promise.resolve(this.connection.prepare(query).run(params).changes);
        }
        catch (e) {
            return this.promise.reject(e);
        }
    }
    executeProcedure(query, params = []) {
        try {
            this.connection.prepare(query).run(params);
            return this.promise.resolve(undefined);
        }
        catch (e) {
            return this.promise.reject(e);
        }
    }
    executeFunction(query, params = []) {
        try {
            const rows = this.connection.prepare(query).safeIntegers(true).all(params);
            if (rows.length > 1) {
                return this.promise.reject(new Error('Too many rows, expected only zero or one row'));
            }
            const row = rows[0];
            if (row) {
                const columns = Object.getOwnPropertyNames(row);
                if (columns.length > 1) {
                    return this.promise.reject(new Error('Too many columns, expected only one column'));
                }
                return this.promise.resolve(toStringInt(row[columns[0]])); // Value in the row of the first column without care about the name
            }
            return this.promise.resolve(undefined);
        }
        catch (e) {
            return this.promise.reject(e);
        }
    }
    executeBeginTransaction() {
        try {
            this.connection.prepare('begin').run();
            return this.promise.resolve(undefined);
        }
        catch (e) {
            return this.promise.reject(e);
        }
    }
    executeCommit() {
        try {
            this.connection.prepare('commit').run();
            return this.promise.resolve(undefined);
        }
        catch (e) {
            return this.promise.reject(e);
        }
    }
    executeRollback() {
        try {
            this.connection.prepare('rollback').run();
            return this.promise.resolve(undefined);
        }
        catch (e) {
            return this.promise.reject(e);
        }
    }
    executeDatabaseSchemaModification(query, params = []) {
        try {
            this.connection.prepare(query).run(params);
            return this.promise.resolve(undefined);
        }
        catch (e) {
            return this.promise.reject(e);
        }
    }
    addParam(params, value) {
        params.push(value);
        return '?';
    }
    addOutParam(_params, _name) {
        throw new Error('Unsupported output parameters');
    }
    createResolvedPromise(result) {
        return this.promise.resolve(result);
    }
}
exports.BetterSqlite3QueryRunner = BetterSqlite3QueryRunner;
function toStringInt(value) {
    if (better_sqlite3_1.Integer && better_sqlite3_1.Integer.isInstance(value)) {
        if (value.isSafe()) {
            return value.toNumber();
        }
        else {
            return value.toString();
        }
    }
    return value;
}
//# sourceMappingURL=BetterSqlite3QueryRunner.js.map