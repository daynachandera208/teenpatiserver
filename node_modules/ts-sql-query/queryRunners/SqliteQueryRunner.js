"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SqliteQueryRunner = void 0;
class SqliteQueryRunner {
    constructor(connection) {
        this.connection = connection;
        this.database = 'sqlite';
    }
    useDatabase(database) {
        if (database !== 'sqlite') {
            throw new Error('Unsupported database: ' + database + '. SqliteQueryRunner only supports sqlite databases');
        }
    }
    getNativeRunner() {
        return this.connection;
    }
    execute(fn) {
        return fn(this.connection);
    }
    executeSelectOneRow(query, params = []) {
        return this.connection.all(query, params).then((rows) => {
            if (rows.length > 1) {
                throw new Error('Too many rows, expected only zero or one row');
            }
            return rows[0];
        });
    }
    executeSelectManyRows(query, params = []) {
        return this.connection.all(query, params);
    }
    executeSelectOneColumnOneRow(query, params = []) {
        return this.connection.all(query, params).then((rows) => {
            if (rows.length > 1) {
                throw new Error('Too many rows, expected only zero or one row');
            }
            const row = rows[0];
            if (row) {
                const columns = Object.getOwnPropertyNames(row);
                if (columns.length > 1) {
                    throw new Error('Too many columns, expected only one column');
                }
                return row[columns[0]]; // Value in the row of the first column without care about the name
            }
            return undefined;
        });
    }
    executeSelectOneColumnManyRows(query, params = []) {
        return this.connection.all(query, params).then((rows) => {
            return rows.map((row) => {
                const columns = Object.getOwnPropertyNames(row);
                if (columns.length > 1) {
                    throw new Error('Too many columns, expected only one column');
                }
                return row[columns[0]]; // Value in the row of the first column without care about the name
            });
        });
    }
    executeInsert(query, params = []) {
        return this.connection.run(query, params).then((result) => result.changes);
    }
    executeInsertReturningLastInsertedId(query, params = []) {
        return this.connection.run(query, params).then((result) => result.lastID);
    }
    executeInsertReturningMultipleLastInsertedId(_query, _params = []) {
        throw new Error('Unsupported executeInsertReturningLastInsertedId for this database');
    }
    executeUpdate(query, params = []) {
        return this.connection.run(query, params).then((result) => result.changes);
    }
    executeDelete(query, params = []) {
        return this.connection.run(query, params).then((result) => result.changes);
    }
    executeProcedure(query, params = []) {
        return this.connection.run(query, params).then(() => undefined);
    }
    executeFunction(query, params = []) {
        return this.connection.all(query, params).then((rows) => {
            if (rows.length > 1) {
                throw new Error('Too many rows, expected only zero or one row');
            }
            const row = rows[0];
            if (row) {
                const columns = Object.getOwnPropertyNames(row);
                if (columns.length > 1) {
                    throw new Error('Too many columns, expected only one column');
                }
                return row[columns[0]]; // Value in the row of the first column without care about the name
            }
            return undefined;
        });
    }
    executeBeginTransaction() {
        return this.connection.run('begin').then(() => undefined);
    }
    executeCommit() {
        return this.connection.run('commit').then(() => undefined);
    }
    executeRollback() {
        return this.connection.run('rollback').then(() => undefined);
    }
    executeDatabaseSchemaModification(query, params = []) {
        return this.connection.run(query, params).then(() => undefined);
    }
    addParam(params, value) {
        params.push(value);
        return '?';
    }
    addOutParam(_params, _name) {
        throw new Error('Unsupported output parameters');
    }
    createResolvedPromise(result) {
        return Promise.resolve(result);
    }
}
exports.SqliteQueryRunner = SqliteQueryRunner;
//# sourceMappingURL=SqliteQueryRunner.js.map