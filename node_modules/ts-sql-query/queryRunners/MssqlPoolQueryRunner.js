"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MssqlPoolQueryRunner = void 0;
const mssql_1 = require("mssql");
class MssqlPoolQueryRunner {
    constructor(pool) {
        this.predefinedTypes = {
            boolean: mssql_1.TYPES.Bit,
            stringInt: mssql_1.TYPES.BigInt,
            int: mssql_1.TYPES.Int,
            bigint: mssql_1.TYPES.BigInt,
            stringDouble: mssql_1.TYPES.Float,
            double: mssql_1.TYPES.Real,
            string: mssql_1.TYPES.NVarChar,
            localDate: mssql_1.TYPES.Date,
            localTime: mssql_1.TYPES.Time,
            localDateTime: mssql_1.TYPES.DateTime2
        };
        this.pool = pool;
        this.database = 'sqlServer';
    }
    useDatabase(database) {
        if (database !== 'sqlServer') {
            throw new Error('Unsupported database: ' + database + '. MssqlPoolQueryRunner only supports sqlServer databases');
        }
    }
    getNativeRunner() {
        return this.pool;
    }
    execute(fn) {
        return fn(this.pool, this.transaction);
    }
    executeSelectOneRow(query, params = []) {
        const req = this.request();
        for (var i = 0, length = params.length; i < length; i++) {
            req.input('' + i, { type: this.getType(params, i) }, params[i]);
        }
        return req.query(query).then((result) => {
            if (!result.recordset) {
                return undefined;
            }
            if (result.recordset.length > 1) {
                throw new Error('Too many rows, expected only zero or one row');
            }
            return result.recordset[0];
        });
    }
    executeSelectManyRows(query, params = []) {
        const req = this.request();
        for (var i = 0, length = params.length; i < length; i++) {
            req.input('' + i, { type: this.getType(params, i) }, params[i]);
        }
        return req.query(query).then((result) => {
            if (!result.recordset) {
                return [];
            }
            return result.recordset;
        });
    }
    executeSelectOneColumnOneRow(query, params = []) {
        const req = this.request();
        for (var i = 0, length = params.length; i < length; i++) {
            req.input('' + i, { type: this.getType(params, i) }, params[i]);
        }
        return req.query(query).then((result) => {
            if (!result.recordset) {
                return undefined;
            }
            if (result.recordset.length > 1) {
                throw new Error('Too many rows, expected only zero or one row');
            }
            const row = result.recordset[0];
            if (row) {
                const columns = Object.getOwnPropertyNames(row);
                if (columns.length > 1) {
                    throw new Error('Too many columns, expected only one column');
                }
                return row[columns[0]]; // Value in the row of the first column without care about the name
            }
            return undefined;
        });
    }
    executeSelectOneColumnManyRows(query, params = []) {
        const req = this.request();
        for (var i = 0, length = params.length; i < length; i++) {
            req.input('' + i, { type: this.getType(params, i) }, params[i]);
        }
        return req.query(query).then((result) => {
            if (!result.recordset) {
                return [];
            }
            return result.recordset.map((row) => {
                const columns = Object.getOwnPropertyNames(row);
                if (columns.length > 1) {
                    throw new Error('Too many columns, expected only one column');
                }
                return row[columns[0]]; // Value in the row of the first column without care about the name
            });
        });
    }
    executeInsert(query, params = []) {
        const req = this.request();
        for (var i = 0, length = params.length; i < length; i++) {
            req.input('' + i, { type: this.getType(params, i) }, params[i]);
        }
        return req.query(query).then((result) => {
            return result.rowsAffected[0];
        });
    }
    executeInsertReturningLastInsertedId(query, params = []) {
        const req = this.request();
        for (var i = 0, length = params.length; i < length; i++) {
            req.input('' + i, { type: this.getType(params, i) }, params[i]);
        }
        return req.query(query).then((result) => {
            if (!result.recordset) {
                throw new Error('Unable to find the last inserted id');
            }
            if (result.recordset.length > 1) {
                throw new Error('Too many rows, expected only zero or one row');
            }
            const row = result.recordset[0];
            if (row) {
                const columns = Object.getOwnPropertyNames(row);
                if (columns.length > 1) {
                    throw new Error('Too many columns, expected only one column');
                }
                return row[columns[0]]; // Value in the row of the first column without care about the name
            }
            throw new Error('Unable to find the last inserted id');
        });
    }
    executeInsertReturningMultipleLastInsertedId(query, params = []) {
        const req = this.request();
        for (var i = 0, length = params.length; i < length; i++) {
            req.input('' + i, { type: this.getType(params, i) }, params[i]);
        }
        return req.query(query).then((result) => {
            if (!result.recordset) {
                throw new Error('Unable to find the last inserted id');
            }
            return result.recordset.map((row) => {
                const columns = Object.getOwnPropertyNames(row);
                if (columns.length > 1) {
                    throw new Error('Too many columns, expected only one column');
                }
                return row[columns[0]]; // Value in the row of the first column without care about the name
            });
        });
    }
    executeUpdate(query, params = []) {
        const req = this.request();
        for (var i = 0, length = params.length; i < length; i++) {
            req.input('' + i, { type: this.getType(params, i) }, params[i]);
        }
        return req.query(query).then((result) => {
            return result.rowsAffected[0];
        });
    }
    executeDelete(query, params = []) {
        const req = this.request();
        for (var i = 0, length = params.length; i < length; i++) {
            req.input('' + i, { type: this.getType(params, i) }, params[i]);
        }
        return req.query(query).then((result) => {
            return result.rowsAffected[0];
        });
    }
    executeProcedure(query, params = []) {
        const req = this.request();
        for (var i = 0, length = params.length; i < length; i++) {
            req.input('' + i, { type: this.getType(params, i) }, params[i]);
        }
        return req.query(query).then(() => undefined);
    }
    executeFunction(query, params = []) {
        const req = this.request();
        for (var i = 0, length = params.length; i < length; i++) {
            req.input('' + i, { type: this.getType(params, i) }, params[i]);
        }
        return req.query(query).then((result) => {
            if (!result.recordset) {
                return undefined;
            }
            if (result.recordset.length > 1) {
                throw new Error('Too many rows, expected only zero or one row');
            }
            const row = result.recordset[0];
            if (row) {
                const columns = Object.getOwnPropertyNames(row);
                if (columns.length > 1) {
                    throw new Error('Too many columns, expected only one column');
                }
                return row[columns[0]]; // Value in the row of the first column without care about the name
            }
            return undefined;
        });
    }
    executeBeginTransaction() {
        if (this.transaction) {
            return Promise.reject(new Error('Already in an transaction, you can only use one transaction'));
        }
        this.transaction = this.pool.transaction();
        return this.transaction.begin().then(() => undefined);
    }
    executeCommit() {
        if (!this.transaction) {
            return Promise.reject(new Error('Not in an transaction, you cannot commit the transaction'));
        }
        return this.transaction.commit().finally(() => {
            this.transaction = undefined;
        });
    }
    executeRollback() {
        if (!this.transaction) {
            return Promise.reject(new Error('Not in an transaction, you cannot rollback the transaction'));
        }
        return this.transaction.rollback().finally(() => {
            this.transaction = undefined;
        });
    }
    executeDatabaseSchemaModification(query, params = []) {
        const req = this.request();
        for (var i = 0, length = params.length; i < length; i++) {
            req.input('' + i, { type: this.getType(params, i) }, params[i]);
        }
        return req.batch(query).then(() => undefined);
    }
    addParam(params, value) {
        const index = params.length;
        params.push(value);
        return '@' + index;
    }
    addOutParam(_params, _name) {
        throw new Error('Unsupported output parameters');
    }
    createResolvedPromise(result) {
        return Promise.resolve(result);
    }
    request() {
        if (this.transaction) {
            return this.transaction.request();
        }
        else {
            return this.pool.request();
        }
    }
    getType(params, index) {
        const definedType = params['@' + index];
        if (definedType) {
            const type = this.predefinedTypes[definedType];
            if (type) {
                return type;
            }
        }
        return this.inferType(params[index]);
    }
    inferType(value) {
        // Inspired by: https://github.com/Hypermediaisobar-admin/node-any-db-mssql/blob/master/index.js
        if (value === null || value === undefined) {
            return mssql_1.TYPES.Variant; // TYPES.Null not included in mssql
        }
        else if (typeof value === 'number') {
            if (Number.isSafeInteger(value)) {
                return mssql_1.TYPES.Int;
            }
            else {
                return mssql_1.TYPES.Real;
            }
        }
        else if (typeof value === 'bigint') {
            return mssql_1.TYPES.BigInt;
        }
        else if (typeof value === 'boolean') {
            return mssql_1.TYPES.Bit;
        }
        else if (value instanceof Array) {
            return (value.length > 0 ? this.inferType(value[0]) : mssql_1.TYPES.Variant); // TYPES.Null not included in mssql
        }
        else if (value instanceof Date) {
            switch (value.___type___) {
                case 'LocalDateTime':
                    return mssql_1.TYPES.DateTime2;
                case 'LocalDate':
                    return mssql_1.TYPES.Date;
                case 'LocalTime':
                    return mssql_1.TYPES.Time;
                default:
                    return mssql_1.TYPES.DateTime2; // Maybe: TYPES.DateTimeOffset
            }
        }
        else if (typeof value === 'string') {
            if (/^-?\d+$/.test(value)) {
                if (value.length > 9) {
                    return mssql_1.TYPES.BigInt;
                }
                else {
                    return mssql_1.TYPES.Int;
                }
            }
            else if (/^-?\d+\.\d+$/.test(value)) {
                return mssql_1.TYPES.Real;
            }
            else if (/^\d{4}-\d{2}-\d{2}$/.test(value)) {
                return mssql_1.TYPES.Date;
            }
            else if (/^\d{2}\:\d{2}(?:\:\d{2})?(?:\+\d{4})?$/.test(value)) {
                return mssql_1.TYPES.Time;
            }
            else if (/^\d{4}-\d{2}-\d{2}\s+\d{2}\:\d{2}(?:\:\d{2}(?:\.\d+)?)?$/.test(value)) {
                return mssql_1.TYPES.DateTime2;
            }
            else if (/^\d{4}-\d{2}-\d{2}T\d{2}\:\d{2}\:\d{2}(?:\.\d+)?$/.test(value)) {
                return mssql_1.TYPES.DateTime2;
            }
            else if (/^\d{4}-\d{2}-\d{2}\s+\d{2}\:\d{2}(?:\:\d{2}(?:\.\d+)?)?(?:[\+\-]\d{2}\:\d{2}|Z)?$/.test(value)) {
                return mssql_1.TYPES.DateTimeOffset;
            }
            else if (/^\d{4}-\d{2}-\d{2}T\d{2}\:\d{2}\:\d{2}(?:\.\d+)?(?:[\+\-]\d{2}\:\d{2}|Z)?$/.test(value)) {
                return mssql_1.TYPES.DateTimeOffset;
            }
            else {
                return mssql_1.TYPES.NVarChar;
            }
        }
        return mssql_1.TYPES.VarBinary;
    }
}
exports.MssqlPoolQueryRunner = MssqlPoolQueryRunner;
//# sourceMappingURL=MssqlPoolQueryRunner.js.map