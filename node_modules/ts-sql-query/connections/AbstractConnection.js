"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AbstractConnection = void 0;
const InsertQueryBuilder_1 = require("../queryBuilders/InsertQueryBuilder");
const UpdateQueryBuilder_1 = require("../queryBuilders/UpdateQueryBuilder");
const DeleteQueryBuilder_1 = require("../queryBuilders/DeleteQueryBuilder");
const values_1 = require("../expressions/values");
const ValueSourceImpl_1 = require("../internal/ValueSourceImpl");
const Default_1 = require("../expressions/Default");
const SelectQueryBuilder_1 = require("../queryBuilders/SelectQueryBuilder");
const chained_error_1 = require("chained-error");
const FragmentQueryBuilder_1 = require("../queryBuilders/FragmentQueryBuilder");
const attachSource_1 = require("../utils/attachSource");
const symbols_1 = require("../utils/symbols");
class AbstractConnection {
    constructor(queryRunner, sqlBuilder) {
        this.allowEmptyString = false;
        this.defaultTypeAdapter = this; // transform protected methods to public
        sqlBuilder._defaultTypeAdapter = this.defaultTypeAdapter;
        this.__sqlBuilder = sqlBuilder;
        this.queryRunner = queryRunner;
        sqlBuilder._queryRunner = queryRunner;
        sqlBuilder._connectionConfiguration = this; // transform protected methods to public
    }
    beginTransaction() {
        const source = new Error('Query executed at');
        try {
            return this.queryRunner.executeBeginTransaction().catch((e) => {
                throw attachSource_1.attachSource(new chained_error_1.default(e), source);
            });
        }
        catch (e) {
            throw new chained_error_1.default(e);
        }
    }
    commit() {
        const source = new Error('Query executed at');
        try {
            return this.queryRunner.executeCommit().catch((e) => {
                throw attachSource_1.attachSource(new chained_error_1.default(e), source);
            });
        }
        catch (e) {
            throw new chained_error_1.default(e);
        }
    }
    rollback() {
        const source = new Error('Query executed at');
        try {
            return this.queryRunner.executeRollback().catch((e) => {
                throw attachSource_1.attachSource(new chained_error_1.default(e), source);
            });
        }
        catch (e) {
            throw new chained_error_1.default(e);
        }
    }
    insertInto(table) {
        return new InsertQueryBuilder_1.InsertQueryBuilder(this.__sqlBuilder, table);
    }
    update(table) {
        return new UpdateQueryBuilder_1.UpdateQueryBuilder(this.__sqlBuilder, table, false);
    }
    updateAllowingNoWhere(table) {
        return new UpdateQueryBuilder_1.UpdateQueryBuilder(this.__sqlBuilder, table, true);
    }
    deleteFrom(table) {
        return new DeleteQueryBuilder_1.DeleteQueryBuilder(this.__sqlBuilder, table, false);
    }
    deleteAllowingNoWhereFrom(table) {
        return new DeleteQueryBuilder_1.DeleteQueryBuilder(this.__sqlBuilder, table, true);
    }
    selectFrom(table) {
        return new SelectQueryBuilder_1.SelectQueryBuilder(this.__sqlBuilder, [table], false); // cast to any to improve typescript performace
    }
    selectDistinctFrom(table) {
        return new SelectQueryBuilder_1.SelectQueryBuilder(this.__sqlBuilder, [table], true); // cast to any to improve typescript performace
    }
    selectFromNoTable() {
        return new SelectQueryBuilder_1.SelectQueryBuilder(this.__sqlBuilder, [], false); // cast to any to improve typescript performace
    }
    subSelectUsing(_table1, _table2, _table3) {
        return new SelectQueryBuilder_1.SelectQueryBuilder(this.__sqlBuilder, [], false); // cast to any to improve typescript performace
    }
    subSelectDistinctUsing(_table1, _table2, _table3) {
        return new SelectQueryBuilder_1.SelectQueryBuilder(this.__sqlBuilder, [], true); // cast to any to improve typescript performace
    }
    default() {
        return new Default_1.DefaultImpl();
    }
    pi() {
        return new ValueSourceImpl_1.SqlOperationStatic0ValueSource(false, '_pi', 'double', undefined);
    }
    random() {
        return new ValueSourceImpl_1.SqlOperationStatic0ValueSource(false, '_random', 'double', undefined);
    }
    currentDate() {
        return new ValueSourceImpl_1.SqlOperationStatic0ValueSource(false, '_currentDate', 'localDate', undefined);
    }
    currentTime() {
        return new ValueSourceImpl_1.SqlOperationStatic0ValueSource(false, '_currentTime', 'localTime', undefined);
    }
    currentDateTime() {
        return new ValueSourceImpl_1.SqlOperationStatic0ValueSource(false, '_currentTimestamp', 'localDateTime', undefined);
    }
    currentTimestamp() {
        return new ValueSourceImpl_1.SqlOperationStatic0ValueSource(false, '_currentTimestamp', 'localDateTime', undefined);
    }
    const(value, type, adapter, adapter2) {
        if (typeof adapter === 'string') {
            return new ValueSourceImpl_1.SqlOperationConstValueSource(false, value, adapter, adapter2);
        }
        return new ValueSourceImpl_1.SqlOperationConstValueSource(false, value, type, adapter);
    }
    optionalConst(value, type, adapter, adapter2) {
        if (typeof adapter === 'string') {
            return new ValueSourceImpl_1.SqlOperationConstValueSource(true, value, adapter, adapter2);
        }
        return new ValueSourceImpl_1.SqlOperationConstValueSource(true, value, type, adapter);
    }
    true() {
        return new ValueSourceImpl_1.SqlOperationStaticBooleanValueSource('_true');
    }
    false() {
        return new ValueSourceImpl_1.SqlOperationStaticBooleanValueSource('_false');
    }
    exists(select) {
        return new ValueSourceImpl_1.SqlOperationStatic1ValueSource(false, '_exists', select, 'boolean', undefined);
    }
    notExists(select) {
        return new ValueSourceImpl_1.SqlOperationStatic1ValueSource(false, '_notExists', select, 'boolean', undefined);
    }
    executeProcedure(procedureName, params) {
        try {
            const queryParams = [];
            const query = this.__sqlBuilder._buildCallProcedure(queryParams, procedureName, params);
            const source = new Error('Query executed at');
            return this.__sqlBuilder._queryRunner.executeProcedure(query, queryParams).catch((e) => {
                throw new chained_error_1.default(e);
            }).catch((e) => {
                throw attachSource_1.attachSource(new chained_error_1.default(e), source);
            });
        }
        catch (e) {
            throw new chained_error_1.default(e);
        }
    }
    executeFunction(functionName, params, returnType, required, adapter, adapter2) {
        try {
            if (typeof adapter === 'string') {
                returnType = required;
                required = adapter;
            }
            else {
                adapter2 = adapter;
            }
            const queryParams = [];
            const query = this.__sqlBuilder._buildCallFunction(queryParams, functionName, params);
            const source = new Error('Query executed at');
            return this.__sqlBuilder._queryRunner.executeFunction(query, queryParams).then((value) => {
                let result;
                if (adapter2) {
                    result = adapter2.transformValueFromDB(value, returnType, this.__sqlBuilder._defaultTypeAdapter);
                }
                else {
                    result = this.__sqlBuilder._defaultTypeAdapter.transformValueFromDB(value, returnType);
                }
                if (result === null || result === undefined) {
                    if (required !== 'optional') {
                        throw new Error('Expected a value as result of the function `' + functionName + '`, but null or undefined value was found');
                    }
                }
                return result;
            }).catch((e) => {
                throw new chained_error_1.default(e);
            }).catch((e) => {
                throw attachSource_1.attachSource(new chained_error_1.default(e), source);
            });
        }
        catch (e) {
            throw new chained_error_1.default(e);
        }
    }
    fragmentWithType(type, required, adapter, adapter2) {
        if (typeof adapter === 'string') {
            type = required;
            required = adapter;
        }
        else {
            adapter2 = adapter;
        }
        const optional = required === 'optional';
        return new FragmentQueryBuilder_1.FragmentQueryBuilder(type, optional, adapter2);
    }
    arg(type, required, adapter, adapter2) {
        if (typeof adapter === 'string') {
            return new values_1.Argument(type, adapter, required, 'combined', adapter2);
        }
        else {
            return new values_1.Argument(type, type, required, 'combined', adapter);
        }
    }
    valueArg(type, required, adapter, adapter2) {
        if (typeof adapter === 'string') {
            return new values_1.Argument(type, adapter, required, 'value', adapter2);
        }
        else {
            return new values_1.Argument(type, type, required, 'value', adapter);
        }
    }
    buildFragmentWithArgs(...args) {
        return new FragmentQueryBuilder_1.FragmentFunctionBuilder(args);
    }
    buildFragmentWithArgsIfValue(...args) {
        return new FragmentQueryBuilder_1.FragmentFunctionBuilderIfValue(this, args); // make this protected fields as public
    }
    noValueBoolean() {
        return new ValueSourceImpl_1.SqlOperationValueSourceIfValueAlwaysNoop();
    }
    countAll() {
        return new ValueSourceImpl_1.AggregateFunctions0ValueSource('_countAll', 'int', undefined);
    }
    count(value) {
        return new ValueSourceImpl_1.AggregateFunctions1ValueSource(false, '_count', value, 'int', undefined);
    }
    countDistinct(value) {
        return new ValueSourceImpl_1.AggregateFunctions1ValueSource(false, '_countDistinct', value, 'int', undefined);
    }
    max(value) {
        const valuePrivate = values_1.__getValueSourcePrivate(value);
        return (new ValueSourceImpl_1.AggregateFunctions1ValueSource(true, '_max', value, valuePrivate.__valueType, valuePrivate.__typeAdapter));
    }
    min(value) {
        const valuePrivate = values_1.__getValueSourcePrivate(value);
        return (new ValueSourceImpl_1.AggregateFunctions1ValueSource(true, '_min', value, valuePrivate.__valueType, valuePrivate.__typeAdapter));
    }
    sum(value) {
        const valuePrivate = values_1.__getValueSourcePrivate(value);
        return new ValueSourceImpl_1.AggregateFunctions1ValueSource(true, '_sum', value, valuePrivate.__valueType, valuePrivate.__typeAdapter);
    }
    sumDistinct(value) {
        const valuePrivate = values_1.__getValueSourcePrivate(value);
        return new ValueSourceImpl_1.AggregateFunctions1ValueSource(true, '_sumDistinct', value, valuePrivate.__valueType, valuePrivate.__typeAdapter);
    }
    average(value) {
        const valuePrivate = values_1.__getValueSourcePrivate(value);
        return new ValueSourceImpl_1.AggregateFunctions1ValueSource(true, '_average', value, valuePrivate.__valueType, valuePrivate.__typeAdapter);
    }
    averageDistinct(value) {
        const valuePrivate = values_1.__getValueSourcePrivate(value);
        return new ValueSourceImpl_1.AggregateFunctions1ValueSource(true, '_averageDistinct', value, valuePrivate.__valueType, valuePrivate.__typeAdapter);
    }
    stringConcat(value, separator) {
        const valuePrivate = values_1.__getValueSourcePrivate(value);
        return new ValueSourceImpl_1.AggregateFunctions1or2ValueSource(true, '_stringConcat', separator, value, valuePrivate.__valueType, valuePrivate.__typeAdapter);
    }
    stringConcatDistinct(value, separator) {
        const valuePrivate = values_1.__getValueSourcePrivate(value);
        return new ValueSourceImpl_1.AggregateFunctions1or2ValueSource(true, '_stringConcatDistinct', separator, value, valuePrivate.__valueType, valuePrivate.__typeAdapter);
    }
    transformValueFromDB(value, type) {
        if (value === undefined) {
            return null;
        }
        if (value === null) {
            return null;
        }
        if (value === '' && !this.allowEmptyString) {
            return null;
        }
        switch (type) {
            case 'boolean':
                if (typeof value === 'boolean') {
                    return value;
                }
                if (typeof value === 'number') {
                    return !!value;
                }
                if (typeof value === 'bigint') {
                    return !!value;
                }
                throw new Error('Invalid boolean value received from the db: ' + value);
            case 'int':
                if (typeof value === 'number') {
                    if (!Number.isInteger(value)) {
                        throw new Error('Invalid int value received from the db: ' + value);
                    }
                    return value;
                }
                if (typeof value === 'string') {
                    const result = +value;
                    if (isNaN(result)) {
                        throw new Error('Invalid int value received from the db: ' + value);
                    }
                    return result;
                }
                if (typeof value === 'bigint') {
                    const result = Number(value);
                    if (!Number.isSafeInteger(result)) {
                        throw new Error('Unnoticed precition lost transforming a bigint to int number. Value: ' + value);
                    }
                    return result;
                }
                throw new Error('Invalid int value received from the db: ' + value);
            case 'stringInt':
                if (typeof value === 'number') {
                    if (!Number.isInteger(value)) {
                        throw new Error('Invalid stringInt value received from the db: ' + value);
                    }
                    return value;
                }
                if (typeof value === 'string') {
                    if (!/^-?\d+$/g.test(value)) {
                        throw new Error('Invalid stringInt value received from the db: ' + value);
                    }
                    return value;
                }
                if (typeof value === 'bigint') {
                    const result = Number(value);
                    if (!Number.isSafeInteger(result)) {
                        return '' + value;
                    }
                    return result;
                }
                throw new Error('Invalid stringInt value received from the db: ' + value);
            case 'bigint':
                if (typeof value === 'number') {
                    if (!Number.isInteger(value)) {
                        throw new Error('Invalid bigint value received from the db: ' + value);
                    }
                    return BigInt(value);
                }
                if (typeof value === 'string') {
                    try {
                        return BigInt(value);
                    }
                    catch {
                        throw new Error('Invalid bigint value received from the db: ' + value);
                    }
                }
                if (typeof value === 'bigint') {
                    return value;
                }
                throw new Error('Invalid int value received from the db: ' + value);
            case 'double':
                if (typeof value === 'number') {
                    return value;
                }
                if (typeof value === 'string') {
                    const result = +value;
                    if (result + '' !== value) { // Here the comparation is not isNaN(result) because NaN is a valid value as well Infinity and -Infinity
                        throw new Error('Invalid double value received from the db: ' + value);
                    }
                    return result;
                }
                if (typeof value === 'bigint') {
                    return Number(value);
                }
                throw new Error('Invalid double value received from the db: ' + value);
            case 'stringDouble':
                if (typeof value === 'number') {
                    return value;
                }
                if (typeof value === 'string') {
                    if (!/^(-?\d+(\.\d+)?|NaN|-?Infinity)$/g.test(value)) {
                        throw new Error('Invalid stringDouble value received from the db: ' + value);
                    }
                    return value;
                }
                if (typeof value === 'bigint') {
                    const result = Number(value);
                    if (!Number.isSafeInteger(result)) {
                        return '' + value;
                    }
                    return result;
                }
                throw new Error('Invalid stringDouble value received from the db: ' + value);
            case 'string':
                if (typeof value === 'string') {
                    return value;
                }
                throw new Error('Invalid string value received from the db: ' + value);
            case 'localDate': {
                let result;
                if (value instanceof Date) {
                    // This time fix works in almost every timezone (from -10 to +13, but not +14, -11, -12, almost uninhabited)
                    result = new Date(Date.UTC(value.getFullYear(), value.getMonth(), value.getDate()));
                    result.setUTCMinutes(600);
                }
                else if (typeof value === 'string') {
                    result = new Date(value + ' 00:00'); // If time is omited, UTC timezone will be used instead the local one
                    // This time fix works in almost every timezone (from -10 to +13, but not +14, -11, -12, almost uninhabited)
                    result = new Date(Date.UTC(result.getFullYear(), result.getMonth(), result.getDate()));
                    result.setUTCMinutes(600);
                }
                else {
                    throw new Error('Invalid localDate value received from the db: ' + value);
                }
                if (isNaN(result.getTime())) {
                    throw new Error('Invalid localDate value received from the db: ' + value);
                }
                result.___type___ = 'localDate';
                return result;
            }
            case 'localTime': {
                let result;
                if (value instanceof Date) {
                    result = value;
                }
                else if (typeof value === 'string') {
                    result = new Date('1970-01-01 ' + value);
                }
                else {
                    throw new Error('Invalid localTime value received from the db: ' + value);
                }
                if (isNaN(result.getTime())) {
                    throw new Error('Invalid localTime value received from the db: ' + value);
                }
                result.___type___ = 'localTime';
                return result;
            }
            case 'localDateTime': {
                let result;
                if (value instanceof Date) {
                    result = value;
                }
                else if (typeof value === 'string') {
                    result = new Date(value);
                }
                else {
                    throw new Error('Invalid localDateTime value received from the db: ' + value);
                }
                if (isNaN(result.getTime())) {
                    throw new Error('Invalid localDateTime value received from the db: ' + value);
                }
                result.___type___ = 'LocalDateTime';
                return result;
            }
            default:
                return value;
        }
    }
    transformValueToDB(value, type) {
        if (value === undefined) {
            return null;
        }
        if (value === null) {
            return null;
        }
        if (value === '' && !this.allowEmptyString) {
            return null;
        }
        switch (type) {
            case 'boolean':
                if (typeof value === 'boolean') {
                    return value;
                }
                throw new Error('Invalid boolean value to send to the db: ' + value);
            case 'int':
                if (typeof value === 'number') {
                    if (!Number.isInteger(value)) {
                        throw new Error('Invalid int value to send to the db: ' + value);
                    }
                    return value;
                }
                throw new Error('Invalid int value to send to the db: ' + value);
            case 'bigint':
                if (typeof value === 'bigint') {
                    return value;
                }
                throw new Error('Invalid int value to send to the db: ' + value);
            case 'stringInt':
                if (typeof value === 'number') {
                    if (!Number.isInteger(value)) {
                        throw new Error('Invalid stringInt value to send to the db: ' + value);
                    }
                    return value;
                }
                if (typeof value === 'string') {
                    if (!/^-?\d+$/g.test(value)) {
                        throw new Error('Invalid stringInt value to send to the db: ' + value);
                    }
                    return value;
                }
                throw new Error('Invalid stringInt value to send to the db: ' + value);
            case 'double':
                if (typeof value === 'number') {
                    return value;
                }
                throw new Error('Invalid double value to send to the db: ' + value);
            case 'stringDouble':
                if (typeof value === 'number') {
                    return value;
                }
                if (typeof value === 'string') {
                    if (!/^(-?\d+(\.\d+)?|NaN|-?Infinity)$/g.test(value)) {
                        throw new Error('Invalid stringDouble value to send to the db: ' + value);
                    }
                    return value;
                }
                throw new Error('Invalid stringDouble value to send to the db: ' + value);
            case 'string':
                if (typeof value === 'string') {
                    return value;
                }
                throw new Error('Invalid string value to send to the db: ' + value);
            case 'localDate':
                if (value instanceof Date && !isNaN(value.getTime())) {
                    return value;
                }
                throw new Error('Invalid localDate value to send to the db: ' + value);
            case 'localTime':
                if (value instanceof Date && !isNaN(value.getTime())) {
                    let result = '';
                    if (value.getHours() > 9) {
                        result += value.getHours();
                    }
                    else {
                        result += '0' + value.getHours();
                    }
                    result += ':';
                    if (value.getMinutes() > 9) {
                        result += value.getMinutes();
                    }
                    else {
                        result += '0' + value.getMinutes();
                    }
                    result += ':';
                    if (value.getSeconds() > 9) {
                        result += value.getSeconds();
                    }
                    else {
                        result += '0' + value.getSeconds();
                    }
                    if (value.getMilliseconds() > 0) {
                        result += '.';
                        if (value.getMilliseconds() > 99) {
                            result += value.getMilliseconds();
                        }
                        else if (value.getMilliseconds() > 9) {
                            result += '0' + value.getMilliseconds();
                        }
                        else {
                            result += '00' + value.getMilliseconds();
                        }
                    }
                    return result;
                }
                throw new Error('Invalid localTime value to send to the db: ' + value);
            case 'localDateTime':
                if (value instanceof Date && !isNaN(value.getTime())) {
                    return value;
                }
                throw new Error('Invalid localDateTime value to send to the db: ' + value);
            default:
                return value;
        }
    }
    isReservedKeyword(word) {
        return this.__sqlBuilder._isReservedKeyword(word);
    }
    forceAsIdentifier(identifier) {
        return this.__sqlBuilder._forceAsIdentifier(identifier);
    }
    escape(identifier) {
        if (this.isReservedKeyword(identifier) || identifier.indexOf(' ') >= 0) {
            return this.forceAsIdentifier(identifier);
        }
        return identifier;
    }
}
exports.AbstractConnection = AbstractConnection;
//# sourceMappingURL=AbstractConnection.js.map