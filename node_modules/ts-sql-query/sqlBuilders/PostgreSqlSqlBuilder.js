"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PostgreSqlSqlBuilder = void 0;
const AbstractSqlBuilder_1 = require("./AbstractSqlBuilder");
class PostgreSqlSqlBuilder extends AbstractSqlBuilder_1.AbstractSqlBuilder {
    constructor() {
        super(...arguments);
        this.postgreSql = true;
    }
    _isReservedKeyword(word) {
        return word.toUpperCase() in reservedWords;
    }
    _appendColumnAlias(name, params) {
        if (!this._isWithGeneratedFinished(params)) {
            // Avoid quote identifiers when the with clause is generated
            return this._escape(name);
        }
        if (name.toLocaleLowerCase() !== name) {
            // Avoid automatically lowercase identifiers by postgresql when it contains uppercase characters
            return this._forceAsIdentifier(name);
        }
        return this._escape(name);
    }
    _buildSelectLimitOffset(query, params) {
        let result = '';
        const limit = query.__limit;
        if (limit !== null && limit !== undefined) {
            result += ' limit ' + this._appendValue(limit, params, 'int', undefined);
        }
        const offset = query.__offset;
        if (offset !== null && offset !== undefined) {
            result += ' offset ' + this._appendValue(offset, params, 'int', undefined);
        }
        return result;
    }
    _asDouble(params, valueSource) {
        return this._appendSqlParenthesis(valueSource, params) + '::float';
    }
    _divide(params, valueSource, value, columnType, typeAdapter) {
        return this._appendSqlParenthesis(valueSource, params) + '::float / ' + this._appendValueParenthesis(value, params, columnType, typeAdapter) + '::float';
    }
    _equalsInsensitive(params, valueSource, value, columnType, typeAdapter) {
        const collation = this._connectionConfiguration.insesitiveCollation;
        if (collation) {
            return this._appendSqlParenthesis(valueSource, params) + ' = ' + this._appendValueParenthesis(value, params, columnType, typeAdapter) + ' collate "' + collation + '"';
        }
        else if (collation === '') {
            return this._appendSqlParenthesis(valueSource, params) + ' = ' + this._appendValueParenthesis(value, params, columnType, typeAdapter);
        }
        else {
            return 'lower(' + this._appendSql(valueSource, params) + ') = lower(' + this._appendValue(value, params, columnType, typeAdapter) + ')';
        }
    }
    _notEqualsInsensitive(params, valueSource, value, columnType, typeAdapter) {
        const collation = this._connectionConfiguration.insesitiveCollation;
        if (collation) {
            return this._appendSqlParenthesis(valueSource, params) + ' <> ' + this._appendValueParenthesis(value, params, columnType, typeAdapter) + ' collate "' + collation + '"';
        }
        else if (collation === '') {
            return this._appendSqlParenthesis(valueSource, params) + ' <> ' + this._appendValueParenthesis(value, params, columnType, typeAdapter);
        }
        else {
            return 'lower(' + this._appendSql(valueSource, params) + ') <> lower(' + this._appendValue(value, params, columnType, typeAdapter) + ')';
        }
    }
    _likeInsensitive(params, valueSource, value, columnType, typeAdapter) {
        const collation = this._connectionConfiguration.insesitiveCollation;
        if (collation) {
            return this._appendSqlParenthesis(valueSource, params) + ' ilike ' + this._appendValueParenthesis(value, params, columnType, typeAdapter) + ' collate "' + collation + '"';
        }
        else {
            return this._appendSqlParenthesis(valueSource, params) + ' ilike ' + this._appendValueParenthesis(value, params, columnType, typeAdapter);
        }
    }
    _notLikeInsensitive(params, valueSource, value, columnType, typeAdapter) {
        const collation = this._connectionConfiguration.insesitiveCollation;
        if (collation) {
            return this._appendSqlParenthesis(valueSource, params) + ' not ilike ' + this._appendValueParenthesis(value, params, columnType, typeAdapter) + ' collate "' + collation + '"';
        }
        else {
            return this._appendSqlParenthesis(valueSource, params) + ' not ilike ' + this._appendValueParenthesis(value, params, columnType, typeAdapter);
        }
    }
    _startWithInsensitive(params, valueSource, value, columnType, typeAdapter) {
        const collation = this._connectionConfiguration.insesitiveCollation;
        if (collation) {
            return this._appendSqlParenthesis(valueSource, params) + ' ilike (' + this._escapeLikeWildcard(params, value, columnType, typeAdapter) + " || '%')" + ' collate "' + collation + '"';
        }
        else {
            return this._appendSqlParenthesis(valueSource, params) + ' ilike (' + this._escapeLikeWildcard(params, value, columnType, typeAdapter) + " || '%')";
        }
    }
    _notStartWithInsensitive(params, valueSource, value, columnType, typeAdapter) {
        const collation = this._connectionConfiguration.insesitiveCollation;
        if (collation) {
            return this._appendSqlParenthesis(valueSource, params) + ' not ilike (' + this._escapeLikeWildcard(params, value, columnType, typeAdapter) + " || '%')" + ' collate "' + collation + '"';
        }
        else {
            return this._appendSqlParenthesis(valueSource, params) + ' not ilike (' + this._escapeLikeWildcard(params, value, columnType, typeAdapter) + " || '%')";
        }
    }
    _endWithInsensitive(params, valueSource, value, columnType, typeAdapter) {
        const collation = this._connectionConfiguration.insesitiveCollation;
        if (collation) {
            return this._appendSqlParenthesis(valueSource, params) + " ilike ('%' || " + this._escapeLikeWildcard(params, value, columnType, typeAdapter) + ') collate "' + collation + '"';
        }
        else {
            return this._appendSqlParenthesis(valueSource, params) + " ilike ('%' || " + this._escapeLikeWildcard(params, value, columnType, typeAdapter) + ')';
        }
    }
    _notEndWithInsensitive(params, valueSource, value, columnType, typeAdapter) {
        const collation = this._connectionConfiguration.insesitiveCollation;
        if (collation) {
            return this._appendSqlParenthesis(valueSource, params) + " not ilike ('%' || " + this._escapeLikeWildcard(params, value, columnType, typeAdapter) + ') collate "' + collation + '"';
        }
        else {
            return this._appendSqlParenthesis(valueSource, params) + " not ilike ('%' || " + this._escapeLikeWildcard(params, value, columnType, typeAdapter) + ')';
        }
    }
    _containsInsensitive(params, valueSource, value, columnType, typeAdapter) {
        const collation = this._connectionConfiguration.insesitiveCollation;
        if (collation) {
            return this._appendSqlParenthesis(valueSource, params) + " ilike ('%' || " + this._escapeLikeWildcard(params, value, columnType, typeAdapter) + " || '%')" + ' collate "' + collation + '"';
        }
        else {
            return this._appendSqlParenthesis(valueSource, params) + " ilike ('%' || " + this._escapeLikeWildcard(params, value, columnType, typeAdapter) + " || '%')";
        }
    }
    _notContainsInsensitive(params, valueSource, value, columnType, typeAdapter) {
        const collation = this._connectionConfiguration.insesitiveCollation;
        if (collation) {
            return this._appendSqlParenthesis(valueSource, params) + " not ilike ('%' || " + this._escapeLikeWildcard(params, value, columnType, typeAdapter) + " || '%')" + ' collate "' + collation + '"';
        }
        else {
            return this._appendSqlParenthesis(valueSource, params) + " not ilike ('%' || " + this._escapeLikeWildcard(params, value, columnType, typeAdapter) + " || '%')";
        }
    }
    _in(params, valueSource, value, columnType, typeAdapter) {
        if (Array.isArray(value)) {
            if (value.length <= 0) {
                return this._falseValueForCondition;
            }
            else {
                return this._appendSqlParenthesis(valueSource, params) + ' in ' + this._appendValue(value, params, columnType, typeAdapter);
            }
        }
        else {
            return this._appendSqlParenthesis(valueSource, params) + ' in (' + this._appendValue(value, params, columnType, typeAdapter) + ')';
        }
    }
    _notIn(params, valueSource, value, columnType, typeAdapter) {
        if (Array.isArray(value)) {
            if (value.length <= 0) {
                return this._trueValueForCondition;
            }
            else {
                return this._appendSqlParenthesis(valueSource, params) + ' not in ' + this._appendValue(value, params, columnType, typeAdapter);
            }
        }
        else {
            return this._appendSqlParenthesis(valueSource, params) + ' not in (' + this._appendValue(value, params, columnType, typeAdapter) + ')';
        }
    }
    _stringConcat(params, separator, value) {
        if (separator === undefined || separator === null) {
            return 'string_agg(' + this._appendSql(value, params) + ", ',')";
        }
        else if (separator === '') {
            return 'string_agg(' + this._appendSql(value, params) + ", '')";
        }
        else {
            return 'string_agg(' + this._appendSql(value, params) + ', ' + this._appendValue(separator, params, 'string', undefined) + ')';
        }
    }
    _stringConcatDistinct(params, separator, value) {
        if (separator === undefined || separator === null) {
            return 'string_agg(distinct ' + this._appendSql(value, params) + ", ',')";
        }
        else if (separator === '') {
            return 'string_agg(distinct ' + this._appendSql(value, params) + ", '')";
        }
        else {
            return 'string_agg(distinct ' + this._appendSql(value, params) + ', ' + this._appendValue(separator, params, 'string', undefined) + ')';
        }
    }
}
exports.PostgreSqlSqlBuilder = PostgreSqlSqlBuilder;
// Source: https://www.postgresql.org/docs/12/sql-keywords-appendix.html (version: 12, only the ones marked as reserved by postgreSql)
const reservedWords = {
    ALL: true,
    ANALYSE: true,
    ANALYZE: true,
    AND: true,
    ANY: true,
    ARRAY: true,
    AS: true,
    ASC: true,
    ASYMMETRIC: true,
    BOTH: true,
    CASE: true,
    CAST: true,
    CHECK: true,
    COLLATE: true,
    COLUMN: true,
    CONSTRAINT: true,
    CREATE: true,
    CURRENT_CATALOG: true,
    CURRENT_DATE: true,
    CURRENT_ROLE: true,
    CURRENT_TIME: true,
    CURRENT_TIMESTAMP: true,
    CURRENT_USER: true,
    DEFAULT: true,
    DEFERRABLE: true,
    DESC: true,
    DISTINCT: true,
    DO: true,
    ELSE: true,
    END: true,
    EXCEPT: true,
    FALSE: true,
    FETCH: true,
    FOR: true,
    FOREIGN: true,
    FROM: true,
    GRANT: true,
    GROUP: true,
    HAVING: true,
    IN: true,
    INITIALLY: true,
    INTERSECT: true,
    INTO: true,
    LATERAL: true,
    LEADING: true,
    LIMIT: true,
    LOCALTIME: true,
    LOCALTIMESTAMP: true,
    NOT: true,
    NULL: true,
    OFFSET: true,
    ON: true,
    ONLY: true,
    OR: true,
    ORDER: true,
    PLACING: true,
    PRIMARY: true,
    REFERENCES: true,
    RETURNING: true,
    SELECT: true,
    SESSION_USER: true,
    SOME: true,
    SYMMETRIC: true,
    TABLE: true,
    THEN: true,
    TO: true,
    TRAILING: true,
    TRUE: true,
    UNION: true,
    UNIQUE: true,
    USER: true,
    USING: true,
    VARIADIC: true,
    WHEN: true,
    WHERE: true,
    WINDOW: true,
    WITH: true,
    AUTHORIZATION: true,
    BINARY: true,
    COLLATION: true,
    CONCURRENTLY: true,
    CROSS: true,
    CURRENT_SCHEMA: true,
    FREEZE: true,
    FULL: true,
    ILIKE: true,
    INNER: true,
    IS: true,
    ISNULL: true,
    JOIN: true,
    LEFT: true,
    LIKE: true,
    NATURAL: true,
    NOTNULL: true,
    OUTER: true,
    OVERLAPS: true,
    RIGHT: true,
    SIMILAR: true,
    TABLESAMPLE: true,
    VERBOSE: true
};
//# sourceMappingURL=PostgreSqlSqlBuilder.js.map