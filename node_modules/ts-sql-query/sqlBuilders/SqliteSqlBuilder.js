"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SqliteSqlBuilder = void 0;
const AbstractSqlBuilder_1 = require("./AbstractSqlBuilder");
const values_1 = require("../expressions/values");
const Column_1 = require("../utils/Column");
class SqliteSqlBuilder extends AbstractSqlBuilder_1.AbstractSqlBuilder {
    constructor() {
        super(...arguments);
        this.sqlite = true;
        this._trueValue = '1';
        this._falseValue = '0';
        this._trueValueForCondition = '1';
        this._falseValueForCondition = '0';
    }
    _isReservedKeyword(word) {
        return word.toUpperCase() in reservedWords;
    }
    _buildSelectOrderBy(query, _params) {
        const orderBy = query.__orderBy;
        if (!orderBy) {
            return '';
        }
        const columns = query.__columns;
        let orderByColumns = '';
        for (const property in orderBy) {
            if (orderByColumns) {
                orderByColumns += ', ';
            }
            const column = columns[property];
            if (!column) {
                throw new Error('Column ' + property + ' included in the order by not found in the select clause');
            }
            const order = orderBy[property];
            if (!order) {
                orderByColumns += this._escape(property);
            }
            else
                switch (order) {
                    case 'asc':
                    case 'asc nulls first':
                        orderByColumns += this._escape(property) + ' asc';
                        break;
                    case 'desc':
                    case 'desc nulls last':
                        orderByColumns += this._escape(property) + ' desc';
                        break;
                    case 'asc nulls last':
                        orderByColumns += this._escape(property) + ' is null, ' + this._escape(property) + ' asc';
                        break;
                    case 'desc nulls first':
                        orderByColumns += this._escape(property) + ' is not null, ' + this._escape(property) + ' desc';
                        break;
                    case 'insensitive':
                        orderByColumns += this._escapeInsensitive(property, column);
                        break;
                    case 'asc insensitive':
                    case 'asc nulls first insensitive':
                        orderByColumns += this._escapeInsensitive(property, column) + ' asc';
                        break;
                    case 'desc insensitive':
                    case 'desc nulls last insensitive':
                        orderByColumns += this._escapeInsensitive(property, column) + ' desc';
                        break;
                    case 'asc nulls last insensitive':
                        orderByColumns += this._escape(property) + ' is null, ' + this._escapeInsensitive(property, column) + ' asc';
                        break;
                    case 'desc nulls first insensitive':
                        orderByColumns += this._escape(property) + ' is not null, ' + this._escapeInsensitive(property, column) + ' desc';
                        break;
                    default:
                        throw new Error('Invalid order by: ' + property + ' ' + order);
                }
        }
        if (!orderByColumns) {
            return '';
        }
        return ' order by ' + orderByColumns;
    }
    _escapeInsensitive(identifier, column) {
        const collation = this._connectionConfiguration.insesitiveCollation;
        const columnType = values_1.__getValueSourcePrivate(column).__valueType;
        if (columnType != 'string') {
            // Ignore the insensitive term, it do nothing
            return this._escape(identifier);
        }
        else if (collation) {
            return this._escape(identifier) + ' collate ' + collation;
        }
        else if (collation === '') {
            return this._escape(identifier);
        }
        else {
            return 'lower(' + this._escape(identifier) + ')';
        }
    }
    _buildSelectLimitOffset(query, params) {
        let result = '';
        const limit = query.__limit;
        if (limit !== null && limit !== undefined) {
            result += ' limit ' + this._appendValue(limit, params, 'int', undefined);
        }
        const offset = query.__offset;
        if (offset !== null && offset !== undefined) {
            result += ' offset ' + this._appendValue(offset, params, 'int', undefined);
        }
        return result;
    }
    _buildInsertOutput(_query, _params) {
        return '';
    }
    _buildInsertReturning(_query, _params) {
        return '';
    }
    _is(params, valueSource, value, columnType, typeAdapter) {
        if (Column_1.isColumn(valueSource) && Column_1.isColumn(value) && this._hasSameBooleanTypeAdapter(valueSource, value)) {
            return this._appendRawColumnName(valueSource, params) + ' is ' + this._appendRawColumnName(value, params);
        }
        return this._appendSqlParenthesis(valueSource, params) + ' is ' + this._appendValueParenthesis(value, params, columnType, typeAdapter);
    }
    _isNot(params, valueSource, value, columnType, typeAdapter) {
        if (Column_1.isColumn(valueSource) && Column_1.isColumn(value) && this._hasSameBooleanTypeAdapter(valueSource, value)) {
            return this._appendRawColumnName(valueSource, params) + ' is not ' + this._appendRawColumnName(value, params);
        }
        return this._appendSqlParenthesis(valueSource, params) + ' is not ' + this._appendValueParenthesis(value, params, columnType, typeAdapter);
    }
    _currentDate(_params) {
        return "date('now')";
    }
    _currentTime(_params) {
        return "time('now')";
    }
    _currentTimestamp(_params) {
        return "datetime('now')";
    }
    _valueWhenNull(params, valueSource, value, columnType, typeAdapter) {
        return 'ifnull(' + this._appendSql(valueSource, params) + ', ' + this._appendValue(value, params, columnType, typeAdapter) + ')';
    }
    _divide(params, valueSource, value, columnType, typeAdapter) {
        return 'cast(' + this._appendSql(valueSource, params) + ' as real) / cast(' + this._appendValue(value, params, columnType, typeAdapter) + ' as real)';
    }
    _asDouble(params, valueSource) {
        return 'cast(' + this._appendSql(valueSource, params) + 'as real)';
    }
    _ln(params, valueSource) {
        return 'log(' + this._appendSql(valueSource, params) + ')';
    }
    _log10(params, valueSource) {
        return 'log10(' + this._appendSql(valueSource, params) + ')';
    }
    _cbrt(params, valueSource) {
        return 'power(' + this._appendSql(valueSource, params) + ', 3)';
    }
    _minValue(params, valueSource, value, columnType, typeAdapter) {
        return 'min(' + this._appendSql(valueSource, params) + ', ' + this._appendValue(value, params, columnType, typeAdapter) + ')';
    }
    _maxValue(params, valueSource, value, columnType, typeAdapter) {
        return 'max(' + this._appendSql(valueSource, params) + ', ' + this._appendValue(value, params, columnType, typeAdapter) + ')';
    }
    _getDate(params, valueSource) {
        return "cast(strftime('%d', " + this._appendSql(valueSource, params) + ") as integer)";
    }
    _getTime(params, valueSource) {
        return "round((julianday(" + this._appendSql(valueSource, params) + ") - 2440587.5) * 86400000.0)";
    }
    _getFullYear(params, valueSource) {
        return "cast(strftime('%Y', " + this._appendSql(valueSource, params) + ") as integer)";
    }
    _getMonth(params, valueSource) {
        return "cast(strftime('%m', " + this._appendSql(valueSource, params) + ") as integer)";
    }
    _getDay(params, valueSource) {
        return "cast(strftime('%w'," + this._appendSql(valueSource, params) + ") as integer)";
    }
    _getHours(params, valueSource) {
        return "cast(strftime('%H', " + this._appendSql(valueSource, params) + ") as integer)";
    }
    _getMinutes(params, valueSource) {
        return "cast(strftime('%M', " + this._appendSql(valueSource, params) + ") as integer)";
    }
    _getSeconds(params, valueSource) {
        return "cast(strftime('%S', " + this._appendSql(valueSource, params) + ") as integer)";
    }
    _getMilliseconds(params, valueSource) {
        return "(strftime('%f', " + this._appendSql(valueSource, params) + " * 1000)) % 1000";
    }
    _like(params, valueSource, value, columnType, typeAdapter) {
        return this._appendSqlParenthesis(valueSource, params) + ' like ' + this._appendValue(value, params, columnType, typeAdapter) + " escape '\\'";
    }
    _notLike(params, valueSource, value, columnType, typeAdapter) {
        return this._appendSqlParenthesis(valueSource, params) + ' not like ' + this._appendValue(value, params, columnType, typeAdapter) + " escape '\\'";
    }
    _likeInsensitive(params, valueSource, value, columnType, typeAdapter) {
        const collation = this._connectionConfiguration.insesitiveCollation;
        if (collation) {
            return this._appendSqlParenthesis(valueSource, params) + ' like (' + this._appendValueParenthesis(value, params, columnType, typeAdapter) + ' collate ' + collation + ") escape '\\'";
        }
        else if (collation === '') {
            return this._appendSqlParenthesis(valueSource, params) + ' like ' + this._appendValueParenthesis(value, params, columnType, typeAdapter) + " escape '\\'";
        }
        else {
            return 'lower(' + this._appendSql(valueSource, params) + ') like lower(' + this._appendValue(value, params, columnType, typeAdapter) + ") escape '\\'";
        }
    }
    _notLikeInsensitive(params, valueSource, value, columnType, typeAdapter) {
        const collation = this._connectionConfiguration.insesitiveCollation;
        if (collation) {
            return this._appendSqlParenthesis(valueSource, params) + ' not like (' + this._appendValueParenthesis(value, params, columnType, typeAdapter) + ' collate ' + collation + ") escape '\\'";
        }
        else if (collation === '') {
            return this._appendSqlParenthesis(valueSource, params) + ' not like ' + this._appendValueParenthesis(value, params, columnType, typeAdapter) + " escape '\\'";
        }
        else {
            return 'lower(' + this._appendSql(valueSource, params) + ') not like lower(' + this._appendValue(value, params, columnType, typeAdapter) + ") escape '\\'";
        }
    }
    _startWith(params, valueSource, value, columnType, typeAdapter) {
        return this._appendSqlParenthesis(valueSource, params) + ' like (' + this._escapeLikeWildcard(params, value, columnType, typeAdapter) + " || '%') escape '\\'";
    }
    _notStartWith(params, valueSource, value, columnType, typeAdapter) {
        return this._appendSqlParenthesis(valueSource, params) + ' not like (' + this._escapeLikeWildcard(params, value, columnType, typeAdapter) + " || '%') escape '\\'";
    }
    _endWith(params, valueSource, value, columnType, typeAdapter) {
        return this._appendSqlParenthesis(valueSource, params) + " like ('%' || " + this._escapeLikeWildcard(params, value, columnType, typeAdapter) + ") escape '\\'";
    }
    _notEndWith(params, valueSource, value, columnType, typeAdapter) {
        return this._appendSqlParenthesis(valueSource, params) + " not like ('%' || " + this._escapeLikeWildcard(params, value, columnType, typeAdapter) + ") escape '\\'";
    }
    _startWithInsensitive(params, valueSource, value, columnType, typeAdapter) {
        const collation = this._connectionConfiguration.insesitiveCollation;
        if (collation) {
            return this._appendSqlParenthesis(valueSource, params) + ' like ((' + this._escapeLikeWildcard(params, value, columnType, typeAdapter) + " || '%') collate " + collation + ") escape '\\'";
        }
        else if (collation === '') {
            return this._appendSqlParenthesis(valueSource, params) + ' like (' + this._escapeLikeWildcard(params, value, columnType, typeAdapter) + " || '%') escape '\\'";
        }
        else {
            return 'lower(' + this._appendSql(valueSource, params) + ') like lower(' + this._escapeLikeWildcard(params, value, columnType, typeAdapter) + " || '%') escape '\\'";
        }
    }
    _notStartWithInsensitive(params, valueSource, value, columnType, typeAdapter) {
        const collation = this._connectionConfiguration.insesitiveCollation;
        if (collation) {
            return this._appendSqlParenthesis(valueSource, params) + ' not like ((' + this._escapeLikeWildcard(params, value, columnType, typeAdapter) + " || '%') collate " + collation + ") escape '\\'";
        }
        else if (collation === '') {
            return this._appendSqlParenthesis(valueSource, params) + ' not like (' + this._escapeLikeWildcard(params, value, columnType, typeAdapter) + " || '%') escape '\\'";
        }
        else {
            return 'lower(' + this._appendSql(valueSource, params) + ') not like lower(' + this._escapeLikeWildcard(params, value, columnType, typeAdapter) + " || '%') escape '\\'";
        }
    }
    _endWithInsensitive(params, valueSource, value, columnType, typeAdapter) {
        const collation = this._connectionConfiguration.insesitiveCollation;
        if (collation) {
            return this._appendSqlParenthesis(valueSource, params) + " like (('%' || " + this._escapeLikeWildcard(params, value, columnType, typeAdapter) + ") collate " + collation + ") escape '\\'";
        }
        else if (collation === '') {
            return this._appendSqlParenthesis(valueSource, params) + " like ('%' || " + this._escapeLikeWildcard(params, value, columnType, typeAdapter) + ") escape '\\'";
        }
        else {
            return 'lower(' + this._appendSql(valueSource, params) + ") like lower('%' || " + this._escapeLikeWildcard(params, value, columnType, typeAdapter) + ") escape '\\'";
        }
    }
    _notEndWithInsensitive(params, valueSource, value, columnType, typeAdapter) {
        const collation = this._connectionConfiguration.insesitiveCollation;
        if (collation) {
            return this._appendSqlParenthesis(valueSource, params) + " not like (('%' || " + this._escapeLikeWildcard(params, value, columnType, typeAdapter) + ") collate " + collation + ") escape '\\'";
        }
        else if (collation === '') {
            return this._appendSqlParenthesis(valueSource, params) + " not like ('%' || " + this._escapeLikeWildcard(params, value, columnType, typeAdapter) + ") escape '\\'";
        }
        else {
            return 'lower(' + this._appendSql(valueSource, params) + ") not like lower('%' || " + this._escapeLikeWildcard(params, value, columnType, typeAdapter) + ") escape '\\'";
        }
    }
    _contains(params, valueSource, value, columnType, typeAdapter) {
        return this._appendSqlParenthesis(valueSource, params) + " like ('%' || " + this._escapeLikeWildcard(params, value, columnType, typeAdapter) + " || '%') escape '\\'";
    }
    _notContains(params, valueSource, value, columnType, typeAdapter) {
        return this._appendSqlParenthesis(valueSource, params) + " not like ('%' || " + this._escapeLikeWildcard(params, value, columnType, typeAdapter) + " || '%') escape '\\'";
    }
    _containsInsensitive(params, valueSource, value, columnType, typeAdapter) {
        const collation = this._connectionConfiguration.insesitiveCollation;
        if (collation) {
            return this._appendSqlParenthesis(valueSource, params) + " like (('%' || " + this._escapeLikeWildcard(params, value, columnType, typeAdapter) + " || '%') collate " + collation + ") escape '\\'";
        }
        else if (collation === '') {
            return this._appendSqlParenthesis(valueSource, params) + " like ('%' || " + this._escapeLikeWildcard(params, value, columnType, typeAdapter) + " || '%') escape '\\'";
        }
        else {
            return 'lower(' + this._appendSql(valueSource, params) + ") like lower('%' || " + this._escapeLikeWildcard(params, value, columnType, typeAdapter) + " || '%') escape '\\'";
        }
    }
    _notContainsInsensitive(params, valueSource, value, columnType, typeAdapter) {
        const collation = this._connectionConfiguration.insesitiveCollation;
        if (collation) {
            return this._appendSqlParenthesis(valueSource, params) + " not like (('%' || " + this._escapeLikeWildcard(params, value, columnType, typeAdapter) + " || '%') collate " + collation + ") escape '\\'";
        }
        else if (collation === '') {
            return this._appendSqlParenthesis(valueSource, params) + " not like ('%' || " + this._escapeLikeWildcard(params, value, columnType, typeAdapter) + " || '%') escape '\\'";
        }
        else {
            return 'lower(' + this._appendSql(valueSource, params) + ") not like lower('%' || " + this._escapeLikeWildcard(params, value, columnType, typeAdapter) + " || '%') escape '\\'";
        }
    }
    _stringConcat(params, separator, value) {
        if (separator === undefined || separator === null) {
            return 'group_concat(' + this._appendSql(value, params) + ')';
        }
        else if (separator === '') {
            return 'group_concat(' + this._appendSql(value, params) + ", '')";
        }
        else {
            return 'group_concat(' + this._appendSql(value, params) + ', ' + this._appendValue(separator, params, 'string', undefined) + ')';
        }
    }
    _stringConcatDistinct(params, separator, value) {
        if (separator === undefined || separator === null) {
            return 'group_concat(distinct ' + this._appendSql(value, params) + ')';
        }
        else if (separator === '') {
            return 'group_concat(distinct ' + this._appendSql(value, params) + ", '')";
        }
        else {
            return 'group_concat(distinct ' + this._appendSql(value, params) + ', ' + this._appendValue(separator, params, 'string', undefined) + ')';
        }
    }
}
exports.SqliteSqlBuilder = SqliteSqlBuilder;
// Source: https://www.sqlite.org/lang_keywords.html (version: 3.30.1)
const reservedWords = {
    ABORT: true,
    ACTION: true,
    ADD: true,
    AFTER: true,
    ALL: true,
    ALTER: true,
    ANALYZE: true,
    AND: true,
    AS: true,
    ASC: true,
    ATTACH: true,
    AUTOINCREMENT: true,
    BEFORE: true,
    BEGIN: true,
    BETWEEN: true,
    BY: true,
    CASCADE: true,
    CASE: true,
    CAST: true,
    CHECK: true,
    COLLATE: true,
    COLUMN: true,
    COMMIT: true,
    CONFLICT: true,
    CONSTRAINT: true,
    CREATE: true,
    CROSS: true,
    CURRENT: true,
    CURRENT_DATE: true,
    CURRENT_TIME: true,
    CURRENT_TIMESTAMP: true,
    DATABASE: true,
    DEFAULT: true,
    DEFERRABLE: true,
    DEFERRED: true,
    DELETE: true,
    DESC: true,
    DETACH: true,
    DISTINCT: true,
    DO: true,
    DROP: true,
    EACH: true,
    ELSE: true,
    END: true,
    ESCAPE: true,
    EXCEPT: true,
    EXCLUDE: true,
    EXCLUSIVE: true,
    EXISTS: true,
    EXPLAIN: true,
    FAIL: true,
    FILTER: true,
    FIRST: true,
    FOLLOWING: true,
    FOR: true,
    FOREIGN: true,
    FROM: true,
    FULL: true,
    GLOB: true,
    GROUP: true,
    GROUPS: true,
    HAVING: true,
    IF: true,
    IGNORE: true,
    IMMEDIATE: true,
    IN: true,
    INDEX: true,
    INDEXED: true,
    INITIALLY: true,
    INNER: true,
    INSERT: true,
    INSTEAD: true,
    INTERSECT: true,
    INTO: true,
    IS: true,
    ISNULL: true,
    JOIN: true,
    KEY: true,
    LAST: true,
    LEFT: true,
    LIKE: true,
    LIMIT: true,
    MATCH: true,
    NATURAL: true,
    NO: true,
    NOT: true,
    NOTHING: true,
    NOTNULL: true,
    NULL: true,
    NULLS: true,
    OF: true,
    OFFSET: true,
    ON: true,
    OR: true,
    ORDER: true,
    OTHERS: true,
    OUTER: true,
    OVER: true,
    PARTITION: true,
    PLAN: true,
    PRAGMA: true,
    PRECEDING: true,
    PRIMARY: true,
    QUERY: true,
    RAISE: true,
    RANGE: true,
    RECURSIVE: true,
    REFERENCES: true,
    REGEXP: true,
    REINDEX: true,
    RELEASE: true,
    RENAME: true,
    REPLACE: true,
    RESTRICT: true,
    RIGHT: true,
    ROLLBACK: true,
    ROW: true,
    ROWS: true,
    SAVEPOINT: true,
    SELECT: true,
    SET: true,
    TABLE: true,
    TEMP: true,
    TEMPORARY: true,
    THEN: true,
    TIES: true,
    TO: true,
    TRANSACTION: true,
    TRIGGER: true,
    UNBOUNDED: true,
    UNION: true,
    UNIQUE: true,
    UPDATE: true,
    USING: true,
    VACUUM: true,
    VALUES: true,
    VIEW: true,
    VIRTUAL: true,
    WHEN: true,
    WHERE: true,
    WINDOW: true,
    WITH: true,
    WITHOUT: true
};
//# sourceMappingURL=SqliteSqlBuilder.js.map