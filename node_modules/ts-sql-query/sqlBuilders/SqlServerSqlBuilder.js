"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SqlServerSqlBuilder = void 0;
const SqlBuilder_1 = require("./SqlBuilder");
const TypeAdapter_1 = require("../TypeAdapter");
const values_1 = require("../expressions/values");
const AbstractSqlBuilder_1 = require("./AbstractSqlBuilder");
const Column_1 = require("../utils/Column");
const values_2 = require("../expressions/values");
class SqlServerSqlBuilder extends AbstractSqlBuilder_1.AbstractSqlBuilder {
    constructor() {
        super();
        this.sqlServer = true;
        this._trueValue = 'convert(bit, 1)';
        this._falseValue = 'convert(bit, 0)';
        this._trueValueForCondition = '(1=1)';
        this._falseValueForCondition = '(0=1)';
        this._nullValueForCondition = '(0=null)';
        this._operationsThatNeedParenthesis._getDate = true;
        this._operationsThatNeedParenthesis._getMilliseconds = false;
    }
    _forceAsIdentifier(identifier) {
        return '[' + identifier + ']';
    }
    _isReservedKeyword(word) {
        return word.toUpperCase() in reservedWords;
    }
    _nextSequenceValue(_params, sequenceName) {
        return 'next value for ' + this._escape(sequenceName);
    }
    _currentSequenceValue(_params, sequenceName) {
        return "(select current_value from sys.sequences where name = '" + sequenceName + "')";
    }
    _appendSql(value, params) {
        if (values_1.isValueSource(value)) {
            const valueSourcePrivate = values_2.__getValueSourcePrivate(value);
            if (valueSourcePrivate.__isBooleanForCondition) {
                if (!valueSourcePrivate.__isResultOptional(this)) {
                    return 'cast(case when ' + super._appendConditionSql(value, params) + ' then 1 else 0 end as bit)';
                }
                else {
                    return 'cast(case when ' + super._appendConditionSql(value, params) + ' then 1 when not ' + super._appendConditionSql(value, params) + ' then 0 else null end as bit)';
                }
            }
        }
        return super._appendSql(value, params);
    }
    _appendConditionParam(value, params, columnType) {
        if (columnType === 'boolean') {
            return '(' + this._appendParam(value, params, columnType) + ' = 1)';
        }
        return this._appendParam(value, params, columnType);
    }
    _appendParam(value, params, columnType) {
        // keep the data type to use in the query runner
        Object.defineProperty(params, '@' + params.length, {
            value: columnType,
            writable: true,
            enumerable: false,
            configurable: true
        });
        return this._queryRunner.addParam(params, value);
    }
    _appendColumnName(column, params) {
        const columnPrivate = Column_1.__getColumnPrivate(column);
        const typeAdapter = columnPrivate.__typeAdapter;
        if (columnPrivate.__valueType === 'boolean') {
            if (typeAdapter instanceof TypeAdapter_1.CustomBooleanTypeAdapter) {
                if (!columnPrivate.__isOptional) {
                    return 'case when ' + this._appendRawColumnName(column, params) + ' = ' + this._appendLiteralValue(typeAdapter.trueValue, params) + ' then 1 else 0 end';
                }
                else {
                    return 'case when ' + this._appendRawColumnName(column, params) + ' = ' + this._appendLiteralValue(typeAdapter.trueValue, params) + ' then 1 when ' + this._appendRawColumnName(column, params) + ' = ' + this._appendLiteralValue(typeAdapter.falseValue, params) + ' then 0 else null end';
                }
            }
        }
        return this._appendRawColumnName(column, params);
    }
    _appendColumnNameForCondition(column, params) {
        const columnPrivate = Column_1.__getColumnPrivate(column);
        const typeAdapter = columnPrivate.__typeAdapter;
        if (columnPrivate.__valueType === 'boolean') {
            if (typeAdapter instanceof TypeAdapter_1.CustomBooleanTypeAdapter) {
                return '(' + this._appendRawColumnName(column, params) + ' = ' + this._appendLiteralValue(typeAdapter.trueValue, params) + ')';
            }
            else {
                return '(' + this._appendRawColumnName(column, params) + ' = 1)';
            }
        }
        return this._appendRawColumnName(column, params);
    }
    _appendSelectColumn(value, params, columnForInsert) {
        if (columnForInsert) {
            const sql = this._appendCustomBooleanRemapForColumnIfRequired(columnForInsert, value, params);
            if (sql) {
                return sql;
            }
        }
        const valueSourcePrivate = values_2.__getValueSourcePrivate(value);
        if (valueSourcePrivate.__isBooleanForCondition) {
            if (!valueSourcePrivate.__isResultOptional(this)) {
                return 'cast(case when ' + this._appendConditionSql(value, params) + ' then 1 else 0 end as bit)';
            }
            else {
                return 'cast(case when ' + this._appendConditionSql(value, params) + ' then 1 when not ' + this._appendConditionSql(value, params) + ' then 0 else null end as bit)';
            }
        }
        return this._appendSql(value, params);
    }
    _buildSelectOrderBy(query, _params) {
        // How to index it: http://www.sqlines.com/oracle/function_based_indexes
        const orderBy = query.__orderBy;
        if (!orderBy) {
            const limit = query.__limit;
            const offset = query.__offset;
            if ((offset !== null && offset !== undefined) || (limit !== null && limit !== undefined)) {
                // Add fake order by to allow a limit and offset without order by
                const columns = query.__columns;
                let index = 0;
                for (const property in columns) {
                    index++;
                    const column = columns[property];
                    if (Column_1.isColumn(column)) {
                        if (Column_1.__getColumnPrivate(column).__isPrimaryKey) {
                            return ' order by ' + index;
                        }
                    }
                }
                return ' order by 1';
            }
            else {
                return '';
            }
        }
        const columns = query.__columns;
        let orderByColumns = '';
        for (const property in orderBy) {
            if (orderByColumns) {
                orderByColumns += ', ';
            }
            const column = columns[property];
            if (!column) {
                throw new Error('Column ' + property + ' included in the order by not found in the select clause');
            }
            const order = orderBy[property];
            if (!order) {
                orderByColumns += property;
            }
            else
                switch (order) {
                    case 'asc':
                    case 'asc nulls first':
                        orderByColumns += this._escape(property) + ' asc';
                        break;
                    case 'desc':
                    case 'desc nulls last':
                        orderByColumns += this._escape(property) + ' desc';
                        break;
                    case 'asc nulls last':
                        orderByColumns += 'iif(' + this._escape(property) + ' is null, 1, 0), ' + this._escape(property) + ' asc';
                        break;
                    case 'desc nulls first':
                        orderByColumns += 'iif(' + this._escape(property) + ' is not null, 1, 0), ' + this._escape(property) + ' desc';
                        break;
                    case 'insensitive':
                        orderByColumns += this._escapeInsensitive(property, column);
                        break;
                    case 'asc insensitive':
                    case 'asc nulls first insensitive':
                        orderByColumns += this._escapeInsensitive(property, column) + ' asc';
                        break;
                    case 'desc insensitive':
                    case 'desc nulls last insensitive':
                        orderByColumns += this._escapeInsensitive(property, column) + ' desc';
                        break;
                    case 'asc nulls last insensitive':
                        orderByColumns += 'iif(' + this._escape(property) + ' is null, 1, 0), ' + this._escapeInsensitive(property, column) + ' asc';
                        break;
                    case 'desc nulls first insensitive':
                        orderByColumns += 'iif(' + this._escape(property) + ' is not null, 1, 0), ' + this._escapeInsensitive(property, column) + ' desc';
                        break;
                    default:
                        throw new Error('Invalid order by: ' + property + ' ' + order);
                }
        }
        if (!orderByColumns) {
            return '';
        }
        return ' order by ' + orderByColumns;
    }
    _escapeInsensitive(identifier, column) {
        const collation = this._connectionConfiguration.insesitiveCollation;
        const columnType = values_2.__getValueSourcePrivate(column).__valueType;
        if (columnType != 'string') {
            // Ignore the insensitive term, it do nothing
            return this._escape(identifier);
        }
        else if (collation) {
            return this._escape(identifier) + ' collate ' + collation;
        }
        else if (collation === '') {
            return this._escape(identifier);
        }
        else {
            return 'lower(' + this._escape(identifier) + ')';
        }
    }
    _buildSelectLimitOffset(query, params) {
        let result = '';
        const limit = query.__limit;
        const offset = query.__offset;
        if (offset !== null && offset !== undefined) {
            result += ' offset ' + this._appendValue(offset, params, 'int', undefined) + ' rows';
        }
        if (limit !== null && limit !== undefined) {
            if (!result) {
                result += ' offset 0 rows';
            }
            result += ' fetch next ' + this._appendValue(limit, params, 'int', undefined) + ' rows only';
        }
        return result;
    }
    _buildInsertOutput(query, params) {
        const idColumn = query.__idColumn;
        if (!idColumn) {
            return '';
        }
        return ' output inserted.' + this._appendSql(idColumn, params);
    }
    _buildInsertReturning(_query, _params) {
        return '';
    }
    _isNullValue(value) {
        if (value === null || value === undefined) {
            return true;
        }
        if (!values_1.isValueSource(value)) {
            return false;
        }
        if (value.isConstValue()) {
            const valueSourceValue = value.getConstValue();
            if (valueSourceValue === null || valueSourceValue === undefined) {
                return true;
            }
        }
        return false;
    }
    _isOptionalValue(value) {
        if (value === null || value === undefined) {
            return true;
        }
        if (!values_1.isValueSource(value)) {
            return false;
        }
        if (value.isConstValue()) {
            const valueSourceValue = value.getConstValue();
            if (valueSourceValue === null || valueSourceValue === undefined) {
                return true;
            }
        }
        return values_2.__getValueSourcePrivate(value).__isResultOptional(this);
    }
    _isNull(params, valueSource) {
        if (Column_1.isColumn(valueSource)) {
            this._appendRawColumnName(valueSource, params) + ' is null';
        }
        if (values_1.isValueSource(valueSource)) {
            const valueSourcePrivate = values_2.__getValueSourcePrivate(valueSource);
            if (valueSourcePrivate.__isBooleanForCondition) {
                if (!valueSourcePrivate.__isResultOptional(this)) {
                    return this._falseValueForCondition;
                }
                else {
                    return '(case when ' + this._appendSqlParenthesis(valueSource, params) + ' then 0 when not ' + this._appendSqlParenthesis(valueSource, params) + ' then 0 else 1 end = 1)';
                }
            }
        }
        return this._appendSqlParenthesis(valueSource, params) + ' is null';
    }
    _generalIsNull(params, value, columnType, typeAdapter) {
        if (SqlBuilder_1.hasToSql(value)) {
            return this._isNull(params, value);
        }
        return this._appendValueParenthesis(value, params, columnType, typeAdapter) + ' is null';
    }
    _isNotNull(params, valueSource) {
        if (Column_1.isColumn(valueSource)) {
            this._appendRawColumnName(valueSource, params) + ' is not null';
        }
        if (values_1.isValueSource(valueSource)) {
            const valueSourcePrivate = values_2.__getValueSourcePrivate(valueSource);
            if (valueSourcePrivate.__isBooleanForCondition) {
                if (!valueSourcePrivate.__isResultOptional(this)) {
                    return this._trueValueForCondition;
                }
                else {
                    return '(case when ' + this._appendSqlParenthesis(valueSource, params) + ' then 1 when not ' + this._appendSqlParenthesis(valueSource, params) + ' then 1 else 0 end = 1)';
                }
            }
        }
        return this._appendSqlParenthesis(valueSource, params) + ' is not null';
    }
    _generalIsNotNull(params, value, columnType, typeAdapter) {
        if (SqlBuilder_1.hasToSql(value)) {
            return this._isNotNull(params, value);
        }
        return this._appendValueParenthesis(value, params, columnType, typeAdapter) + ' is not null';
    }
    _is(params, valueSource, value, columnType, typeAdapter) {
        const valueIsNull = this._isNullValue(value);
        const valueSourceIsNull = this._isNullValue(valueSource);
        const valueIsOptional = this._isOptionalValue(value);
        const valueSourceIsOptional = this._isOptionalValue(valueSource);
        if (valueIsNull) {
            return this._isNull(params, valueSource);
        }
        if (valueSourceIsNull) {
            // We know value is null or undefined, then, whe need to ensure the value source is null as well
            return this._generalIsNull(params, value, columnType, typeAdapter);
        }
        if (valueSourceIsOptional && valueIsOptional) {
            return 'case when (' + this._equals(params, valueSource, value, columnType, typeAdapter) + ') or (' + this._isNull(params, valueSource) + ' and ' + this._generalIsNull(params, value, columnType, typeAdapter) + ') then 1 else 0 end = 1';
        }
        else if (valueSourceIsOptional || valueIsOptional) {
            return 'case when ' + this._equals(params, valueSource, value, columnType, typeAdapter) + ' then 1 else 0 end = 1';
        }
        else {
            return this._equals(params, valueSource, value, columnType, typeAdapter);
        }
        // Alternative implementation that avoid evaluate multiple times the arguments
        // return 'exists(select ' + this._appendSqlParenthesis(valueSource, params) + ' intersect select ' + this._appendValueParenthesis(value, params, columnType, typeAdapter) + ')'
    }
    _isNot(params, valueSource, value, columnType, typeAdapter) {
        const valueIsNull = this._isNullValue(value);
        const valueSourceIsNull = this._isNullValue(valueSource);
        const valueIsOptional = this._isOptionalValue(value);
        const valueSourceIsOptional = this._isOptionalValue(valueSource);
        if (valueIsNull) {
            return this._isNotNull(params, valueSource);
        }
        if (valueSourceIsNull) {
            // We know value is null or undefined, then, whe need to ensure the value source is null as well
            return this._generalIsNotNull(params, value, columnType, typeAdapter);
        }
        if (valueSourceIsOptional && valueIsOptional) {
            return 'not (case when (' + this._equals(params, valueSource, value, columnType, typeAdapter) + ') or (' + this._isNull(params, valueSource) + ' and ' + this._generalIsNull(params, value, columnType, typeAdapter) + ') then 1 else 0 end = 1)';
        }
        else if (valueSourceIsOptional || valueIsOptional) {
            return 'not (case when ' + this._equals(params, valueSource, value, columnType, typeAdapter) + ' then 1 else 0 end = 1)';
        }
        else {
            return this._notEquals(params, valueSource, value, columnType, typeAdapter);
        }
        // Alternative implementation that avoid evaluate multiple times the arguments
        // return 'not exists(select ' + this._appendSqlParenthesis(valueSource, params) + ' intersect select ' + this._appendValueParenthesis(value, params, columnType, typeAdapter) + ')'
    }
    _valueWhenNull(params, valueSource, value, columnType, typeAdapter) {
        return 'isnull(' + this._appendSql(valueSource, params) + ', ' + this._appendValue(value, params, columnType, typeAdapter) + ')';
    }
    _escapeLikeWildcard(params, value, columnType, typeAdapter) {
        if (typeof value === 'string') {
            value = value.replace(/\[/g, '[[]');
            value = value.replace(/%/g, '[%]');
            value = value.replace(/_/g, '[]');
            return this._appendValue(value, params, columnType, typeAdapter);
        }
        else {
            return "replace(replace(replace(" + this._appendValue(value, params, columnType, typeAdapter) + ", '[', '[[]'), '%', '[%]'), '_', '[]')";
        }
    }
    _startWith(params, valueSource, value, columnType, typeAdapter) {
        return this._appendSqlParenthesis(valueSource, params) + ' like (' + this._escapeLikeWildcard(params, value, columnType, typeAdapter) + " + '%')";
    }
    _notStartWith(params, valueSource, value, columnType, typeAdapter) {
        return this._appendSqlParenthesis(valueSource, params) + ' not like (' + this._escapeLikeWildcard(params, value, columnType, typeAdapter) + " + '%')";
    }
    _endWith(params, valueSource, value, columnType, typeAdapter) {
        return this._appendSqlParenthesis(valueSource, params) + " like ('%' + " + this._escapeLikeWildcard(params, value, columnType, typeAdapter) + ')';
    }
    _notEndWith(params, valueSource, value, columnType, typeAdapter) {
        return this._appendSqlParenthesis(valueSource, params) + " not like ('%' + " + this._escapeLikeWildcard(params, value, columnType, typeAdapter) + ')';
    }
    _startWithInsensitive(params, valueSource, value, columnType, typeAdapter) {
        const collation = this._connectionConfiguration.insesitiveCollation;
        if (collation) {
            return this._appendSqlParenthesis(valueSource, params) + ' like (' + this._escapeLikeWildcard(params, value, columnType, typeAdapter) + " + '%') collate " + collation;
        }
        else if (collation === '') {
            return this._appendSqlParenthesis(valueSource, params) + ' like (' + this._escapeLikeWildcard(params, value, columnType, typeAdapter) + " + '%')";
        }
        else {
            return 'lower(' + this._appendSql(valueSource, params) + ') like lower(' + this._escapeLikeWildcard(params, value, columnType, typeAdapter) + " + '%')";
        }
    }
    _notStartWithInsensitive(params, valueSource, value, columnType, typeAdapter) {
        const collation = this._connectionConfiguration.insesitiveCollation;
        if (collation) {
            return this._appendSqlParenthesis(valueSource, params) + ' not like (' + this._escapeLikeWildcard(params, value, columnType, typeAdapter) + " + '%') collate " + collation;
        }
        else if (collation === '') {
            return this._appendSqlParenthesis(valueSource, params) + ' not like (' + this._escapeLikeWildcard(params, value, columnType, typeAdapter) + " + '%')";
        }
        else {
            return 'lower(' + this._appendSql(valueSource, params) + ') not like lower(' + this._escapeLikeWildcard(params, value, columnType, typeAdapter) + " + '%')";
        }
    }
    _endWithInsensitive(params, valueSource, value, columnType, typeAdapter) {
        const collation = this._connectionConfiguration.insesitiveCollation;
        if (collation) {
            return this._appendSqlParenthesis(valueSource, params) + " like ('%' + " + this._escapeLikeWildcard(params, value, columnType, typeAdapter) + ') collate ' + collation;
        }
        else if (collation === '') {
            return this._appendSqlParenthesis(valueSource, params) + " like ('%' + " + this._escapeLikeWildcard(params, value, columnType, typeAdapter) + ')';
        }
        else {
            return 'lower(' + this._appendSql(valueSource, params) + ") like lower('%' + " + this._escapeLikeWildcard(params, value, columnType, typeAdapter) + ')';
        }
    }
    _notEndWithInsensitive(params, valueSource, value, columnType, typeAdapter) {
        const collation = this._connectionConfiguration.insesitiveCollation;
        if (collation) {
            return this._appendSqlParenthesis(valueSource, params) + " not like ('%' + " + this._escapeLikeWildcard(params, value, columnType, typeAdapter) + ') collate ' + collation;
        }
        else if (collation === '') {
            return this._appendSqlParenthesis(valueSource, params) + " not like ('%' + " + this._escapeLikeWildcard(params, value, columnType, typeAdapter) + ')';
        }
        else {
            return 'lower(' + this._appendSql(valueSource, params) + ") not like lower('%' + " + this._escapeLikeWildcard(params, value, columnType, typeAdapter) + ')';
        }
    }
    _contains(params, valueSource, value, columnType, typeAdapter) {
        return this._appendSqlParenthesis(valueSource, params) + " like ('%' + " + this._escapeLikeWildcard(params, value, columnType, typeAdapter) + " + '%')";
    }
    _notContains(params, valueSource, value, columnType, typeAdapter) {
        return this._appendSqlParenthesis(valueSource, params) + " not like ('%' + " + this._escapeLikeWildcard(params, value, columnType, typeAdapter) + " + '%')";
    }
    _containsInsensitive(params, valueSource, value, columnType, typeAdapter) {
        const collation = this._connectionConfiguration.insesitiveCollation;
        if (collation) {
            return this._appendSqlParenthesis(valueSource, params) + " like ('%' + " + this._escapeLikeWildcard(params, value, columnType, typeAdapter) + " + '%') collate " + collation;
        }
        else if (collation === '') {
            return this._appendSqlParenthesis(valueSource, params) + " like ('%' + " + this._escapeLikeWildcard(params, value, columnType, typeAdapter) + " + '%')";
        }
        else {
            return 'lower(' + this._appendSql(valueSource, params) + ") like lower('%' + " + this._escapeLikeWildcard(params, value, columnType, typeAdapter) + " + '%')";
        }
    }
    _notContainsInsensitive(params, valueSource, value, columnType, typeAdapter) {
        const collation = this._connectionConfiguration.insesitiveCollation;
        if (collation) {
            return this._appendSqlParenthesis(valueSource, params) + " not like ('%' + " + this._escapeLikeWildcard(params, value, columnType, typeAdapter) + " + '%') collate " + collation;
        }
        else if (collation === '') {
            return this._appendSqlParenthesis(valueSource, params) + " not like ('%' + " + this._escapeLikeWildcard(params, value, columnType, typeAdapter) + " + '%')";
        }
        else {
            return 'lower(' + this._appendSql(valueSource, params) + ") not like lower('%' + " + this._escapeLikeWildcard(params, value, columnType, typeAdapter) + " + '%')";
        }
    }
    _currentDate() {
        return 'getdate()';
    }
    _currentTime() {
        return 'convert(time, current_timestamp)';
    }
    _random() {
        return 'rand()';
    }
    _divide(params, valueSource, value, columnType, typeAdapter) {
        return 'cast(' + this._appendSql(valueSource, params) + ' as float) / cast(' + this._appendValue(value, params, columnType, typeAdapter) + ' as float)';
    }
    _asDouble(params, valueSource) {
        return 'cast(' + this._appendSql(valueSource, params) + 'as float)';
    }
    _concat(params, valueSource, value, columnType, typeAdapter) {
        return this._appendSqlParenthesisExcluding(valueSource, params, '_concat') + ' + ' + this._appendValueParenthesisExcluding(value, params, columnType, typeAdapter, '_concat');
    }
    _length(params, valueSource) {
        return 'len(' + valueSource.__toSql(this, params) + ')';
    }
    _ln(params, valueSource) {
        return 'log(' + valueSource.__toSql(this, params) + ')';
    }
    _log10(params, valueSource) {
        return 'log10(' + valueSource.__toSql(this, params) + ')';
    }
    _cbrt(params, valueSource) {
        return 'power(' + valueSource.__toSql(this, params) + ', 3)';
    }
    _atan2(params, valueSource, value, columnType, typeAdapter) {
        return 'atn2(' + valueSource.__toSql(this, params) + ', ' + this._appendValue(value, params, columnType, typeAdapter) + ')';
    }
    _minValue(params, valueSource, value, columnType, typeAdapter) {
        return 'iif(' + this._appendSql(valueSource, params) + ' < ' + this._appendValue(value, params, columnType, typeAdapter) + ', ' + this._appendSql(valueSource, params) + ', ' + this._appendValue(value, params, columnType, typeAdapter) + ')';
        // Alternative implementation that avoid evaluate multiple times the arguments
        // if (isColumn(valueSource) || !isValueSource(valueSource) || valueSource.isConstValue()) {
        //     if (isColumn(value) || !isValueSource(value) || value.isConstValue()) {
        //         // Both values are repeteables, then, we can use the sql that compare both values repeting them
        //         return 'iif(' + this._appendSql(valueSource, params) + ' < ' + this._appendValue(value, params, columnType, typeAdapter) + ', ' + this._appendSql(valueSource, params) + ', ' + this._appendValue(value, params, columnType, typeAdapter) + ')'
        //     }
        // }
        // return '(select min(__minValue__) from (values (' + this._appendSql(valueSource, params) + '), (' + this._appendSql(valueSource, params) + ')) as __minValueTable__(__minValue__))'
    }
    _maxValue(params, valueSource, value, columnType, typeAdapter) {
        return 'iif(' + this._appendSql(valueSource, params) + ' > ' + this._appendValue(value, params, columnType, typeAdapter) + ', ' + this._appendSql(valueSource, params) + ', ' + this._appendValue(value, params, columnType, typeAdapter) + ')';
        // Alternative implementation that avoid evaluate multiple times the arguments
        // if (isColumn(valueSource) || !isValueSource(valueSource) || valueSource.getConstValue()) {
        //     if (isColumn(value) || !isValueSource(value) || value.isConstValue()) {
        //         // Both values are repeteables, then, we can use the sql that compare both values repeting them
        //         return 'iif(' + this._appendSql(valueSource, params) + ' > ' + this._appendValue(value, params, columnType, typeAdapter) + ', ' + this._appendSql(valueSource, params) + ', ' + this._appendValue(value, params, columnType, typeAdapter) + ')'
        //     }
        // }
        // return '(select max(__maxValue__) from (values (' + this._appendSql(valueSource, params) + '), (' + this._appendSql(valueSource, params) + ')) as __maxValueTable__(__maxValue__))'
    }
    _getDate(params, valueSource) {
        return 'datepart(day, ' + this._appendSql(valueSource, params) + ')';
    }
    _getTime(params, valueSource) {
        return "datediff_big(millisecond, '1970-01-01 00:00:00', " + this._appendSql(valueSource, params) + ")";
    }
    _getFullYear(params, valueSource) {
        return 'datepart(year, ' + this._appendSql(valueSource, params) + ')';
    }
    _getMonth(params, valueSource) {
        return 'datepart(month, ' + this._appendSql(valueSource, params) + ')';
    }
    _getDay(params, valueSource) {
        return 'datepart(weekday, ' + this._appendSql(valueSource, params) + ') - 1';
    }
    _getHours(params, valueSource) {
        return 'datepart(hour, ' + this._appendSql(valueSource, params) + ')';
    }
    _getMinutes(params, valueSource) {
        return 'datepart(minute, ' + this._appendSql(valueSource, params) + ')';
    }
    _getSeconds(params, valueSource) {
        return 'datepart(second, ' + this._appendSql(valueSource, params) + ')';
    }
    _getMilliseconds(params, valueSource) {
        return 'datepart(millisecond, ' + this._appendSql(valueSource, params) + ')';
    }
    _buildCallProcedure(params, functionName, functionParams) {
        let result = 'exec ' + this._escape(functionName);
        for (let i = 0, length = functionParams.length; i < length; i++) {
            result += ' ' + this._appendSql(functionParams[i], params);
        }
        return result;
    }
    _stringConcat(params, separator, value) {
        if (separator === undefined || separator === null) {
            return 'string_agg(' + this._appendSql(value, params) + ", ',')";
        }
        else if (separator === '') {
            return 'string_agg(' + this._appendSql(value, params) + ", '')";
        }
        else {
            return 'string_agg(' + this._appendSql(value, params) + ', ' + this._appendValue(separator, params, 'string', undefined) + ')';
        }
    }
    _stringConcatDistinct(params, separator, value) {
        if (separator === undefined || separator === null) {
            return 'string_agg(distinct ' + this._appendSql(value, params) + ", ',')";
        }
        else if (separator === '') {
            return 'string_agg(distinct ' + this._appendSql(value, params) + ", '')";
        }
        else {
            return 'string_agg(distinct ' + this._appendSql(value, params) + ', ' + this._appendValue(separator, params, 'string', undefined) + ')';
        }
    }
    _in(params, valueSource, value, columnType, typeAdapter) {
        if (Array.isArray(value)) {
            if (value.length <= 0) {
                return this._falseValueForCondition;
            }
            else {
                return this._appendSqlParenthesis(valueSource, params) + ' in ' + this._appendValue(value, params, columnType, typeAdapter);
            }
        }
        else {
            return this._appendSqlParenthesis(valueSource, params) + ' in (' + this._appendValue(value, params, columnType, typeAdapter) + ')';
        }
    }
    _notIn(params, valueSource, value, columnType, typeAdapter) {
        if (Array.isArray(value)) {
            if (value.length <= 0) {
                return this._trueValueForCondition;
            }
            else {
                return this._appendSqlParenthesis(valueSource, params) + ' not in ' + this._appendValue(value, params, columnType, typeAdapter);
            }
        }
        else {
            return this._appendSqlParenthesis(valueSource, params) + ' not in (' + this._appendValue(value, params, columnType, typeAdapter) + ')';
        }
    }
}
exports.SqlServerSqlBuilder = SqlServerSqlBuilder;
// Source: https://docs.microsoft.com/en-us/sql/t-sql/language-elements/reserved-keywords-transact-sql?view=sql-server-ver15 (version: SqlServer 2019, all possible keywords combined)
const reservedWords = {
    ABSOLUTE: true,
    ACTION: true,
    ADA: true,
    ADD: true,
    ADMIN: true,
    AFTER: true,
    AGGREGATE: true,
    ALIAS: true,
    ALL: true,
    ALLOCATE: true,
    ALTER: true,
    AND: true,
    ANY: true,
    ARE: true,
    ARRAY: true,
    AS: true,
    ASC: true,
    ASENSITIVE: true,
    ASSERTION: true,
    ASYMMETRIC: true,
    AT: true,
    ATOMIC: true,
    AUTHORIZATION: true,
    AVG: true,
    BACKUP: true,
    BEFORE: true,
    BEGIN: true,
    BETWEEN: true,
    BINARY: true,
    BIT: true,
    BIT_LENGTH: true,
    BLOB: true,
    BOOLEAN: true,
    BOTH: true,
    BREADTH: true,
    BREAK: true,
    BROWSE: true,
    BULK: true,
    BY: true,
    CALL: true,
    CALLED: true,
    CARDINALITY: true,
    CASCADE: true,
    CASCADED: true,
    CASE: true,
    CAST: true,
    CATALOG: true,
    CHAR: true,
    CHAR_LENGTH: true,
    CHARACTER: true,
    CHARACTER_LENGTH: true,
    CHECK: true,
    CHECKPOINT: true,
    CLASS: true,
    CLOB: true,
    CLOSE: true,
    CLUSTERED: true,
    COALESCE: true,
    COLLATE: true,
    COLLATION: true,
    COLLECT: true,
    COLUMN: true,
    COMMIT: true,
    COMPLETION: true,
    COMPUTE: true,
    CONDITION: true,
    CONNECT: true,
    CONNECTION: true,
    CONSTRAINT: true,
    CONSTRAINTS: true,
    CONSTRUCTOR: true,
    CONTAINS: true,
    CONTAINSTABLE: true,
    CONTINUE: true,
    CONVERT: true,
    CORR: true,
    CORRESPONDING: true,
    COUNT: true,
    COVAR_POP: true,
    COVAR_SAMP: true,
    CREATE: true,
    CROSS: true,
    CUBE: true,
    CUME_DIST: true,
    CURRENT: true,
    CURRENT_CATALOG: true,
    CURRENT_DATE: true,
    CURRENT_DEFAULT_TRANSFORM_GROUP: true,
    CURRENT_PATH: true,
    CURRENT_ROLE: true,
    CURRENT_SCHEMA: true,
    CURRENT_TIME: true,
    CURRENT_TIMESTAMP: true,
    CURRENT_TRANSFORM_GROUP_FOR_TYPE: true,
    CURRENT_USER: true,
    CURSOR: true,
    CYCLE: true,
    DATA: true,
    DATABASE: true,
    DATE: true,
    DAY: true,
    DBCC: true,
    DEALLOCATE: true,
    DEC: true,
    DECIMAL: true,
    DECLARE: true,
    DEFAULT: true,
    DEFERRABLE: true,
    DEFERRED: true,
    DELETE: true,
    DENY: true,
    DEPTH: true,
    DEREF: true,
    DESC: true,
    DESCRIBE: true,
    DESCRIPTOR: true,
    DESTROY: true,
    DESTRUCTOR: true,
    DETERMINISTIC: true,
    DIAGNOSTICS: true,
    DICTIONARY: true,
    DISCONNECT: true,
    DISK: true,
    DISTINCT: true,
    DISTRIBUTED: true,
    DOMAIN: true,
    DOUBLE: true,
    DROP: true,
    DUMP: true,
    DYNAMIC: true,
    EACH: true,
    ELEMENT: true,
    ELSE: true,
    'END-EXEC': true,
    END: true,
    EQUALS: true,
    ERRLVL: true,
    ESCAPE: true,
    EVERY: true,
    EXCEPT: true,
    EXCEPTION: true,
    EXEC: true,
    EXECUTE: true,
    EXISTS: true,
    EXIT: true,
    EXTERNAL: true,
    EXTRACT: true,
    FALSE: true,
    FETCH: true,
    FILE: true,
    FILLFACTOR: true,
    FILTER: true,
    FIRST: true,
    FLOAT: true,
    FOR: true,
    FOREIGN: true,
    FORTRAN: true,
    FOUND: true,
    FREE: true,
    FREETEXT: true,
    FREETEXTTABLE: true,
    FROM: true,
    FULL: true,
    FULLTEXTTABLE: true,
    FUNCTION: true,
    FUSION: true,
    GENERAL: true,
    GET: true,
    GLOBAL: true,
    GO: true,
    GOTO: true,
    GRANT: true,
    GROUP: true,
    GROUPING: true,
    HAVING: true,
    HOLD: true,
    HOLDLOCK: true,
    HOST: true,
    HOUR: true,
    IDENTITY: true,
    IDENTITY_INSERT: true,
    IDENTITYCOL: true,
    IF: true,
    IGNORE: true,
    IMMEDIATE: true,
    IN: true,
    INCLUDE: true,
    INDEX: true,
    INDICATOR: true,
    INITIALIZE: true,
    INITIALLY: true,
    INNER: true,
    INOUT: true,
    INPUT: true,
    INSENSITIVE: true,
    INSERT: true,
    INT: true,
    INTEGER: true,
    INTERSECT: true,
    INTERSECTION: true,
    INTERVAL: true,
    INTO: true,
    IS: true,
    ISOLATION: true,
    ITERATE: true,
    JOIN: true,
    KEY: true,
    KILL: true,
    LABEL: true,
    LANGUAGE: true,
    LARGE: true,
    LAST: true,
    LATERAL: true,
    LEADING: true,
    LEFT: true,
    LESS: true,
    LEVEL: true,
    LIKE: true,
    LIKE_REGEX: true,
    LIMIT: true,
    LINENO: true,
    LN: true,
    LOAD: true,
    LOCAL: true,
    LOCALTIME: true,
    LOCALTIMESTAMP: true,
    LOCATOR: true,
    LOWER: true,
    MAP: true,
    MATCH: true,
    MAX: true,
    MEMBER: true,
    MERGE: true,
    METHOD: true,
    MIN: true,
    MINUTE: true,
    MOD: true,
    MODIFIES: true,
    MODIFY: true,
    MODULE: true,
    MONTH: true,
    MULTISET: true,
    NAMES: true,
    NATIONAL: true,
    NATURAL: true,
    NCHAR: true,
    NCLOB: true,
    NEW: true,
    NEXT: true,
    NO: true,
    NOCHECK: true,
    NONCLUSTERED: true,
    NONE: true,
    NORMALIZE: true,
    NOT: true,
    NULL: true,
    NULLIF: true,
    NUMERIC: true,
    OBJECT: true,
    OCCURRENCES_REGEX: true,
    OCTET_LENGTH: true,
    OF: true,
    OFF: true,
    OFFSETS: true,
    OLD: true,
    ON: true,
    ONLY: true,
    OPEN: true,
    OPENDATASOURCE: true,
    OPENQUERY: true,
    OPENROWSET: true,
    OPENXML: true,
    OPERATION: true,
    OPTION: true,
    OR: true,
    ORDER: true,
    ORDINALITY: true,
    OUT: true,
    OUTER: true,
    OUTPUT: true,
    OVER: true,
    OVERLAPS: true,
    OVERLAY: true,
    PAD: true,
    PARAMETER: true,
    PARAMETERS: true,
    PARTIAL: true,
    PARTITION: true,
    PASCAL: true,
    PATH: true,
    PERCENT: true,
    PERCENT_RANK: true,
    PERCENTILE_CONT: true,
    PERCENTILE_DISC: true,
    PIVOT: true,
    PLAN: true,
    POSITION: true,
    POSITION_REGEX: true,
    POSTFIX: true,
    PRECISION: true,
    PREFIX: true,
    PREORDER: true,
    PREPARE: true,
    PRESERVE: true,
    PRIMARY: true,
    PRINT: true,
    PRIOR: true,
    PRIVILEGES: true,
    PROC: true,
    PROCEDURE: true,
    PUBLIC: true,
    RAISERROR: true,
    RANGE: true,
    READ: true,
    READS: true,
    READTEXT: true,
    REAL: true,
    RECONFIGURE: true,
    RECURSIVE: true,
    REF: true,
    REFERENCES: true,
    REFERENCING: true,
    REGR_AVGX: true,
    REGR_AVGY: true,
    REGR_COUNT: true,
    REGR_INTERCEPT: true,
    REGR_R2: true,
    REGR_SLOPE: true,
    REGR_SXX: true,
    REGR_SXY: true,
    REGR_SYY: true,
    RELATIVE: true,
    RELEASE: true,
    REPLICATION: true,
    RESTORE: true,
    RESTRICT: true,
    RESULT: true,
    RETURN: true,
    RETURNS: true,
    REVERT: true,
    REVOKE: true,
    RIGHT: true,
    ROLE: true,
    ROLLBACK: true,
    ROLLUP: true,
    ROUTINE: true,
    ROW: true,
    ROWCOUNT: true,
    ROWGUIDCOL: true,
    ROWS: true,
    RULE: true,
    SAVE: true,
    SAVEPOINT: true,
    SCHEMA: true,
    SCOPE: true,
    SCROLL: true,
    SEARCH: true,
    SECOND: true,
    SECTION: true,
    SECURITYAUDIT: true,
    SELECT: true,
    SEMANTICKEYPHRASETABLE: true,
    SEMANTICSIMILARITYDETAILSTABLE: true,
    SEMANTICSIMILARITYTABLE: true,
    SENSITIVE: true,
    SEQUENCE: true,
    SESSION: true,
    SESSION_USER: true,
    SET: true,
    SETS: true,
    SETUSER: true,
    SHUTDOWN: true,
    SIMILAR: true,
    SIZE: true,
    SMALLINT: true,
    SOME: true,
    SPACE: true,
    SPECIFIC: true,
    SPECIFICTYPE: true,
    SQL: true,
    SQLCA: true,
    SQLCODE: true,
    SQLERROR: true,
    SQLEXCEPTION: true,
    SQLSTATE: true,
    SQLWARNING: true,
    START: true,
    STATE: true,
    STATEMENT: true,
    STATIC: true,
    STATISTICS: true,
    STDDEV_POP: true,
    STDDEV_SAMP: true,
    STRUCTURE: true,
    SUBMULTISET: true,
    SUBSTRING: true,
    SUBSTRING_REGEX: true,
    SUM: true,
    SYMMETRIC: true,
    SYSTEM: true,
    SYSTEM_USER: true,
    TABLE: true,
    TABLESAMPLE: true,
    TEMPORARY: true,
    TERMINATE: true,
    TEXTSIZE: true,
    THAN: true,
    THEN: true,
    TIME: true,
    TIMESTAMP: true,
    TIMEZONE_HOUR: true,
    TIMEZONE_MINUTE: true,
    TO: true,
    TOP: true,
    TRAILING: true,
    TRAN: true,
    TRANSACTION: true,
    TRANSLATE: true,
    TRANSLATE_REGEX: true,
    TRANSLATION: true,
    TREAT: true,
    TRIGGER: true,
    TRIM: true,
    TRUE: true,
    TRUNCATE: true,
    TRY_CONVERT: true,
    TSEQUAL: true,
    UESCAPE: true,
    UNDER: true,
    UNION: true,
    UNIQUE: true,
    UNKNOWN: true,
    UNNEST: true,
    UNPIVOT: true,
    UPDATE: true,
    UPDATETEXT: true,
    UPPER: true,
    USAGE: true,
    USE: true,
    USER: true,
    USING: true,
    VALUE: true,
    VALUES: true,
    VAR_POP: true,
    VAR_SAMP: true,
    VARCHAR: true,
    VARIABLE: true,
    VARYING: true,
    VIEW: true,
    WAITFOR: true,
    WHEN: true,
    WHENEVER: true,
    WHERE: true,
    WHILE: true,
    WIDTH_BUCKET: true,
    WINDOW: true,
    WITH: true,
    'WITHIN GROUP': true,
    WITHIN: true,
    WITHOUT: true,
    WORK: true,
    WRITE: true,
    WRITETEXT: true,
    XMLAGG: true,
    XMLATTRIBUTES: true,
    XMLBINARY: true,
    XMLCAST: true,
    XMLCOMMENT: true,
    XMLCONCAT: true,
    XMLDOCUMENT: true,
    XMLELEMENT: true,
    XMLEXISTS: true,
    XMLFOREST: true,
    XMLITERATE: true,
    XMLNAMESPACES: true,
    XMLPARSE: true,
    XMLPI: true,
    XMLQUERY: true,
    XMLSERIALIZE: true,
    XMLTABLE: true,
    XMLTEXT: true,
    XMLVALIDATE: true,
    YEAR: true,
    ZONE: true,
};
//# sourceMappingURL=SqlServerSqlBuilder.js.map